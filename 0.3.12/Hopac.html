<!doctype html>
<html lang="en">
<head>
<link rel="icon" href="https://avatars2.githubusercontent.com/u/10173903">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.1.1/normalize.css">
<link rel="stylesheet" href="fsirefgen.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/github.min.css">
<script src="fsirefgen.js" async></script>
<title>Hopac Library Reference</title>
<nav><div class="navbar"><span><img src="https://avatars2.githubusercontent.com/u/10173903" width="16" height="16"><a href="https://github.com/Hopac/Hopac">Hopac</a>0.3.12</span><a href="#">Top</a></div></nav>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Hopac Library Reference</h1>
<h2>Synopsis</h2>
<pre><code class="fsharp hljs">namespace <a id="dec:namespace Hopac" href="#def:namespace%20Hopac">Hopac</a>
</code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Void" href="#def:type%20Hopac.Void">Void</a>
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.IAsyncDisposable" href="#def:type%20Hopac.IAsyncDisposable">IAsyncDisposable</a> =
  abstract <a id="dec:abstract Hopac.IAsyncDisposable.DisposeAsync" href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Job" href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Job" href="#def:module%20Hopac.Job">Job</a> =
  <a id="Hopac.Job.spawning-jobs" href="#Hopac.Job.spawning-jobs" class="h3">// Spawning jobs</a>
  val <a id="dec:val Hopac.Job.queue" href="#def:val%20Hopac.Job.queue">queue</a>:       <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.queueIgnore" href="#def:val%20Hopac.Job.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.server" href="#def:val%20Hopac.Job.server">server</a>:      <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.start" href="#def:val%20Hopac.Job.start">start</a>:       <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.startIgnore" href="#def:val%20Hopac.Job.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.basic-combinators" href="#Hopac.Job.basic-combinators" class="h3">// Basic combinators</a>
  val <a id="dec:val Hopac.Job.result" href="#def:val%20Hopac.Job.result">result</a>: 'x   -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val   <a id="dec:val Hopac.Job.unit" href="#def:val%20Hopac.Job.unit">unit</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.bind" href="#def:val%20Hopac.Job.bind">bind</a>:      ('x   -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.delayWith" href="#def:val%20Hopac.Job.delayWith">delayWith</a>: ('x   -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt;     'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.map" href="#def:val%20Hopac.Job.map">map</a>:       ('x   -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.lift" href="#def:val%20Hopac.Job.lift">lift</a>:      ('x   -&gt;      'y)  -&gt;     'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.delay" href="#def:val%20Hopac.Job.delay">delay</a>:     (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;)            -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.thunk" href="#def:val%20Hopac.Job.thunk">thunk</a>:     (unit -&gt;      'y)             -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.join" href="#def:val%20Hopac.Job.join">join</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.abort" href="#def:val%20Hopac.Job.abort">abort</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val <a id="dec:val Hopac.Job.Ignore" href="#def:val%20Hopac.Job.Ignore">Ignore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.exception-handling" href="#Hopac.Job.exception-handling" class="h3">// Exception handling</a>
  val <a id="dec:val Hopac.Job.raises" href="#def:val%20Hopac.Job.raises">raises</a>: exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val <a id="dec:val Hopac.Job.tryIn" href="#def:val%20Hopac.Job.tryIn">tryIn</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;  -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.tryInDelay" href="#def:val%20Hopac.Job.tryInDelay">tryInDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.tryWith" href="#def:val%20Hopac.Job.tryWith">tryWith</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;  -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.tryWithDelay" href="#def:val%20Hopac.Job.tryWithDelay">tryWithDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.tryFinallyJob" href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;  -&gt;      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.tryFinallyJobDelay" href="#def:val%20Hopac.Job.tryFinallyJobDelay">tryFinallyJobDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt;      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.tryFinallyFun" href="#def:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;  -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.tryFinallyFunDelay" href="#def:val%20Hopac.Job.tryFinallyFunDelay">tryFinallyFunDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.catch" href="#def:val%20Hopac.Job.catch">catch</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Choice&lt;'x, exn&gt;&gt;
  <a id="Hopac.Job.finalization" href="#Hopac.Job.finalization" class="h3">// Finalization</a>
  val <a id="dec:val Hopac.Job.useIn" href="#def:val%20Hopac.Job.useIn">useIn</a>:      ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
  val <a id="dec:val Hopac.Job.using" href="#def:val%20Hopac.Job.using">using</a>:      'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
  val <a id="dec:val Hopac.Job.usingAsync" href="#def:val%20Hopac.Job.usingAsync">usingAsync</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; <a href="#def:type%20Hopac.IAsyncDisposable">IAsyncDisposable</a>
  <a id="Hopac.Job.repeating-an-operation" href="#Hopac.Job.repeating-an-operation" class="h3">// Repeating an operation</a>
  val <a id="dec:val Hopac.Job.forN" href="#def:val%20Hopac.Job.forN">forN</a>:       int -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.forNIgnore" href="#def:val%20Hopac.Job.forNIgnore">forNIgnore</a>: int -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.iterating-over-a-range" href="#Hopac.Job.iterating-over-a-range" class="h3">// Iterating over a range</a>
  val <a id="dec:val Hopac.Job.forUpTo" href="#def:val%20Hopac.Job.forUpTo">forUpTo</a>:         int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.forUpToIgnore" href="#def:val%20Hopac.Job.forUpToIgnore">forUpToIgnore</a>:   int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.forDownTo" href="#def:val%20Hopac.Job.forDownTo">forDownTo</a>:       int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.forDownToIgnore" href="#def:val%20Hopac.Job.forDownToIgnore">forDownToIgnore</a>: int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.iterating-conditionally" href="#Hopac.Job.iterating-conditionally" class="h3">// Iterating conditionally</a>
  val <a id="dec:val Hopac.Job.whileDo" href="#def:val%20Hopac.Job.whileDo">whileDo</a>:       (unit -&gt; bool) -&gt;           <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.whileDoDelay" href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a>:  (unit -&gt; bool) -&gt; (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)   -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.whileDoIgnore" href="#def:val%20Hopac.Job.whileDoIgnore">whileDoIgnore</a>: (unit -&gt; bool) -&gt;           <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.conditional" href="#Hopac.Job.conditional" class="h3">// Conditional</a>
  val <a id="dec:val Hopac.Job.whenDo" href="#def:val%20Hopac.Job.whenDo">whenDo</a>: bool -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.server-loops" href="#Hopac.Job.server-loops" class="h3">// Server loops</a>
  val <a id="dec:val Hopac.Job.forever" href="#def:val%20Hopac.Job.forever">forever</a>:       <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val <a id="dec:val Hopac.Job.foreverIgnore" href="#def:val%20Hopac.Job.foreverIgnore">foreverIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val <a id="dec:val Hopac.Job.iterate" href="#def:val%20Hopac.Job.iterate">iterate</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  <a id="Hopac.Job.spawning-server-loops" href="#Hopac.Job.spawning-server-loops" class="h3">// Spawning server loops</a>
  val <a id="dec:val Hopac.Job.foreverServer" href="#def:val%20Hopac.Job.foreverServer">foreverServer</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.iterateServer" href="#def:val%20Hopac.Job.iterateServer">iterateServer</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.sequences-of-jobs" href="#Hopac.Job.sequences-of-jobs" class="h3">// Sequences of jobs</a>
  val <a id="dec:val Hopac.Job.seqCollect" href="#def:val%20Hopac.Job.seqCollect">seqCollect</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Job.conCollect" href="#def:val%20Hopac.Job.conCollect">conCollect</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Job.seqIgnore" href="#def:val%20Hopac.Job.seqIgnore">seqIgnore</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.conIgnore" href="#def:val%20Hopac.Job.conIgnore">conIgnore</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Job.interop" href="#Hopac.Job.interop" class="h3">// Interop</a>
  val <a id="dec:val Hopac.Job.fromBeginEnd" href="#def:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a>: doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
                 -&gt; doEnd: (IAsyncResult -&gt; 'x)
                 -&gt; Job&lt;'x&gt;
  val <a id="dec:val Hopac.Job.fromEndBegin" href="#def:val%20Hopac.Job.fromEndBegin">fromEndBegin</a>: doEnd: (IAsyncResult -&gt; 'x)
                 -&gt; doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
                 -&gt; Job&lt;'x&gt;
  val <a id="dec:val Hopac.Job.fromContinuations" href="#def:val%20Hopac.Job.fromContinuations">fromContinuations</a>: (('x -&gt; unit) -&gt; (exn -&gt; unit) -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.fromAsync" href="#def:val%20Hopac.Job.fromAsync">fromAsync</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val   <a id="dec:val Hopac.Job.toAsync" href="#def:val%20Hopac.Job.toAsync">toAsync</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.bindAsync" href="#def:val%20Hopac.Job.bindAsync">bindAsync</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.fromTask" href="#def:val%20Hopac.Job.fromTask">fromTask</a>:     (unit -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.fromUnitTask" href="#def:val%20Hopac.Job.fromUnitTask">fromUnitTask</a>: (unit -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>)     -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.liftTask" href="#def:val%20Hopac.Job.liftTask">liftTask</a>:     ('x -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'y&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.liftUnitTask" href="#def:val%20Hopac.Job.liftUnitTask">liftUnitTask</a>: ('x -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>)     -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.awaitTask" href="#def:val%20Hopac.Job.awaitTask">awaitTask</a>:     <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Job.awaitUnitTask" href="#def:val%20Hopac.Job.awaitUnitTask">awaitUnitTask</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>     -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Job.bindTask" href="#def:val%20Hopac.Job.bindTask">bindTask</a>:     ('x   -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Job.bindUnitTask" href="#def:val%20Hopac.Job.bindUnitTask">bindUnitTask</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>     -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  <a id="Hopac.Job.debugging" href="#Hopac.Job.debugging" class="h3">// Debugging</a>
  val <a id="dec:val Hopac.Job.paranoid" href="#def:val%20Hopac.Job.paranoid">paranoid</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
<span class="spacing">  module <a id="dec:module Hopac.Job.Scheduler" href="#def:module%20Hopac.Job.Scheduler">Scheduler</a> =
    val <a id="dec:val Hopac.Job.Scheduler.bind" href="#def:val%20Hopac.Job.Scheduler.bind">bind</a>: (Scheduler -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Job.Scheduler.get" href="#def:val%20Hopac.Job.Scheduler.get">get</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Scheduler&gt;
    val <a id="dec:val Hopac.Job.Scheduler.switchToWorker" href="#def:val%20Hopac.Job.Scheduler.switchToWorker">switchToWorker</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Job.Scheduler.isolate" href="#def:val%20Hopac.Job.Scheduler.isolate">isolate</a>: (unit -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Job.Random" href="#def:module%20Hopac.Job.Random">Random</a> =
    val <a id="dec:val Hopac.Job.Random.bind" href="#def:val%20Hopac.Job.Random.bind">bind</a>: (uint64 -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val  <a id="dec:val Hopac.Job.Random.map" href="#def:val%20Hopac.Job.Random.map">map</a>: (uint64 -&gt;      'x)  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Job.Random.get" href="#def:val%20Hopac.Job.Random.get">get</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;uint64&gt;
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Alt" href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.Alt.Job" href="#def:inherit%20Hopac.Alt.Job">Job</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Alt" href="#def:module%20Hopac.Alt">Alt</a> =
  <a id="Hopac.Alt.basic-alternatives" href="#Hopac.Alt.basic-alternatives" class="h3">// Basic alternatives</a>
  val <a id="dec:val Hopac.Alt.always" href="#def:val%20Hopac.Alt.always">always</a>: 'x   -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val   <a id="dec:val Hopac.Alt.unit" href="#def:val%20Hopac.Alt.unit">unit</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Alt.once" href="#def:val%20Hopac.Alt.once">once</a>: 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.never" href="#def:val%20Hopac.Alt.never">never</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Alt.zero" href="#def:val%20Hopac.Alt.zero">zero</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Alt.Ignore" href="#def:val%20Hopac.Alt.Ignore">Ignore</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  <a id="Hopac.Alt.before-actions" href="#Hopac.Alt.before-actions" class="h3">// Before actions</a>
  val <a id="dec:val Hopac.Alt.prepareJob" href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.prepare" href="#def:val%20Hopac.Alt.prepare">prepare</a>:              <a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt;  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.prepareFun" href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a>: (unit -&gt;      #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.Alt.negative-acknowledgments" href="#Hopac.Alt.negative-acknowledgments" class="h3">// Negative acknowledgments</a>
  val <a id="dec:val Hopac.Alt.withNackJob" href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a>: (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.withNackFun" href="#def:val%20Hopac.Alt.withNackFun">withNackFun</a>: (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt;      #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.wrapAbortJob" href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a>:      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.wrapAbortFun" href="#def:val%20Hopac.Alt.wrapAbortFun">wrapAbortFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.Alt.choices" href="#Hopac.Alt.choices" class="h3">// Choices</a>
  val <a id="dec:val Hopac.Alt.choose" href="#def:val%20Hopac.Alt.choose">choose</a>:   seq&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.choosy" href="#def:val%20Hopac.Alt.choosy">choosy</a>: array&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.Alt.randomization" href="#Hopac.Alt.randomization" class="h3">// Randomization</a>
  val <a id="dec:val Hopac.Alt.random" href="#def:val%20Hopac.Alt.random">random</a>: (uint64 -&gt; #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.chooser" href="#def:val%20Hopac.Alt.chooser">chooser</a>:  seq&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.Alt.after-actions" href="#Hopac.Alt.after-actions" class="h3">// After actions</a>
  val <a id="dec:val Hopac.Alt.afterJob" href="#def:val%20Hopac.Alt.afterJob">afterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Alt.afterFun" href="#def:val%20Hopac.Alt.afterFun">afterFun</a>: ('x -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  <a id="Hopac.Alt.exception-handling" href="#Hopac.Alt.exception-handling" class="h3">// Exception handling</a>
  val <a id="dec:val Hopac.Alt.raises" href="#def:val%20Hopac.Alt.raises">raises</a>: exn -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
  val <a id="dec:val Hopac.Alt.tryIn" href="#def:val%20Hopac.Alt.tryIn">tryIn</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Alt.tryFinallyJob" href="#def:val%20Hopac.Alt.tryFinallyJob">tryFinallyJob</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt;      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.tryFinallyFun" href="#def:val%20Hopac.Alt.tryFinallyFun">tryFinallyFun</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.Alt.interop" href="#Hopac.Alt.interop" class="h3">// Interop</a>
  val <a id="dec:val Hopac.Alt.fromBeginEnd" href="#def:val%20Hopac.Alt.fromBeginEnd">fromBeginEnd</a>: doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
                 -&gt; doEnd: (IAsyncResult -&gt; 'x)
                 -&gt; doCancel: (IAsyncResult -&gt; unit)
                 -&gt; Alt&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.fromAsync" href="#def:val%20Hopac.Alt.fromAsync">fromAsync</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val   <a id="dec:val Hopac.Alt.toAsync" href="#def:val%20Hopac.Alt.toAsync">toAsync</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.fromTask" href="#def:val%20Hopac.Alt.fromTask">fromTask</a>:     (CancellationToken -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Alt.fromUnitTask" href="#def:val%20Hopac.Alt.fromUnitTask">fromUnitTask</a>: (CancellationToken -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>)     -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  <a id="Hopac.Alt.debugging" href="#Hopac.Alt.debugging" class="h3">// Debugging</a>
  val <a id="dec:val Hopac.Alt.paranoid" href="#def:val%20Hopac.Alt.paranoid">paranoid</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Promise" href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.Promise.Alt" href="#def:inherit%20Hopac.Promise.Alt">Alt</a>&lt;'x&gt;
  <a id="dec:new Hopac.Promise.new" href="#def:new%20Hopac.Promise.new">new</a>: unit    -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  <a id="dec:new Hopac.Promise.1.new" href="#def:new%20Hopac.Promise.1.new">new</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  <a id="dec:new Hopac.Promise.2.new" href="#def:new%20Hopac.Promise.2.new">new</a>:     'x  -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  <a id="dec:new Hopac.Promise.3.new" href="#def:new%20Hopac.Promise.3.new">new</a>: exn     -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Promise" href="#def:module%20Hopac.Promise">Promise</a> =
  val <a id="dec:val Hopac.Promise.queue" href="#def:val%20Hopac.Promise.queue">queue</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Promise.start" href="#def:val%20Hopac.Promise.start">start</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Promise.read" href="#def:val%20Hopac.Promise.read">read</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
<span class="spacing">  module <a id="dec:module Hopac.Promise.Now" href="#def:module%20Hopac.Promise.Now">Now</a> =
    val <a id="dec:val Hopac.Promise.Now.isFulfilled" href="#def:val%20Hopac.Promise.Now.isFulfilled">isFulfilled</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; bool
    val <a id="dec:val Hopac.Promise.Now.get" href="#def:val%20Hopac.Promise.Now.get">get</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; 'x
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Ch" href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.Ch.Alt" href="#def:inherit%20Hopac.Ch.Alt">Alt</a>&lt;'x&gt;
  <a id="dec:new Hopac.Ch.new" href="#def:new%20Hopac.Ch.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Ch" href="#def:module%20Hopac.Ch">Ch</a> =
  val <a id="dec:val Hopac.Ch.give" href="#def:val%20Hopac.Ch.give">give</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Ch.send" href="#def:val%20Hopac.Ch.send">send</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Ch.take" href="#def:val%20Hopac.Ch.take">take</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
<span class="spacing">  module <a id="dec:module Hopac.Ch.Try" href="#def:module%20Hopac.Ch.Try">Try</a> =
    val <a id="dec:val Hopac.Ch.Try.give" href="#def:val%20Hopac.Ch.Try.give">give</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;
    val <a id="dec:val Hopac.Ch.Try.take" href="#def:val%20Hopac.Ch.Try.take">take</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'x&gt;&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Ch.Now" href="#def:module%20Hopac.Ch.Now">Now</a> =
    val <a id="dec:val Hopac.Ch.Now.send" href="#def:val%20Hopac.Ch.Now.send">send</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; unit
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.IVar" href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.IVar.Promise" href="#def:inherit%20Hopac.IVar.Promise">Promise</a>&lt;'x&gt;
  <a id="dec:new Hopac.IVar.new" href="#def:new%20Hopac.IVar.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
  <a id="dec:new Hopac.IVar.1.new" href="#def:new%20Hopac.IVar.1.new">new</a>: 'x   -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
  <a id="dec:new Hopac.IVar.2.new" href="#def:new%20Hopac.IVar.2.new">new</a>: exn  -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.IVar" href="#def:module%20Hopac.IVar">IVar</a> =
  val    <a id="dec:val Hopac.IVar.fill" href="#def:val%20Hopac.IVar.fill">fill</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.IVar.tryFill" href="#def:val%20Hopac.IVar.tryFill">tryFill</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val    <a id="dec:val Hopac.IVar.fillFailure" href="#def:val%20Hopac.IVar.fillFailure">fillFailure</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.IVar.tryFillFailure" href="#def:val%20Hopac.IVar.tryFillFailure">tryFillFailure</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.IVar.read" href="#def:val%20Hopac.IVar.read">read</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
<span class="spacing">  module <a id="dec:module Hopac.IVar.Now" href="#def:module%20Hopac.IVar.Now">Now</a> =
    val <a id="dec:val Hopac.IVar.Now.isFull" href="#def:val%20Hopac.IVar.Now.isFull">isFull</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; bool
    val <a id="dec:val Hopac.IVar.Now.get" href="#def:val%20Hopac.IVar.Now.get">get</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Latch" href="#def:type%20Hopac.Latch">Latch</a> =
  inherit <a id="dec:inherit Hopac.Latch.Alt" href="#def:inherit%20Hopac.Latch.Alt">Alt</a>&lt;unit&gt;
  <a id="dec:new Hopac.Latch.new" href="#def:new%20Hopac.Latch.new">new</a>: int -&gt; <a href="#def:type%20Hopac.Latch">Latch</a>
</span><span class="spacing">module <a id="dec:module Hopac.Latch" href="#def:module%20Hopac.Latch">Latch</a> =
  <a id="Hopac.Latch.await" href="#Hopac.Latch.await" class="h3">// Await</a>
  val <a id="dec:val Hopac.Latch.await" href="#def:val%20Hopac.Latch.await">await</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  <a id="Hopac.Latch.higher-order-interface" href="#Hopac.Latch.higher-order-interface" class="h3">// Higher-order interface</a>
  val <a id="dec:val Hopac.Latch.within" href="#def:val%20Hopac.Latch.within">within</a>: (<a href="#def:type%20Hopac.Latch">Latch</a> -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Latch.holding" href="#def:val%20Hopac.Latch.holding">holding</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Latch.queue" href="#def:val%20Hopac.Latch.queue">queue</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Latch.queueAsPromise" href="#def:val%20Hopac.Latch.queueAsPromise">queueAsPromise</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
  <a id="Hopac.Latch.first-order-interface" href="#Hopac.Latch.first-order-interface" class="h3">// First-order interface</a>
  val <a id="dec:val Hopac.Latch.decrement" href="#def:val%20Hopac.Latch.decrement">decrement</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
<span class="spacing">  module <a id="dec:module Hopac.Latch.Now" href="#def:module%20Hopac.Latch.Now">Now</a> =
    val <a id="dec:val Hopac.Latch.Now.increment" href="#def:val%20Hopac.Latch.Now.increment">increment</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; unit
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.MVar" href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.MVar.Alt" href="#def:inherit%20Hopac.MVar.Alt">Alt</a>&lt;'x&gt;
  <a id="dec:new Hopac.MVar.new" href="#def:new%20Hopac.MVar.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;
  <a id="dec:new Hopac.MVar.1.new" href="#def:new%20Hopac.MVar.1.new">new</a>: 'x   -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.MVar" href="#def:module%20Hopac.MVar">MVar</a> =
  <a id="Hopac.MVar.primitives" href="#Hopac.MVar.primitives" class="h3">// Primitives</a>
  val <a id="dec:val Hopac.MVar.fill" href="#def:val%20Hopac.MVar.fill">fill</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.MVar.take" href="#def:val%20Hopac.MVar.take">take</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.MVar.read" href="#Hopac.MVar.read" class="h3">// Read</a>
  val <a id="dec:val Hopac.MVar.read" href="#def:val%20Hopac.MVar.read">read</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  <a id="Hopac.MVar.mutate" href="#Hopac.MVar.mutate" class="h3">// Mutate</a>
  val    <a id="dec:val Hopac.MVar.mutateJob" href="#def:val%20Hopac.MVar.mutateJob">mutateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.MVar.tryMutateJob" href="#def:val%20Hopac.MVar.tryMutateJob">tryMutateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val    <a id="dec:val Hopac.MVar.mutateFun" href="#def:val%20Hopac.MVar.mutateFun">mutateFun</a>: ('x -&gt;      'x)  -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.MVar.tryMutateFun" href="#def:val%20Hopac.MVar.tryMutateFun">tryMutateFun</a>: ('x -&gt;      'x)  -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  <a id="Hopac.MVar.modify" href="#Hopac.MVar.modify" class="h3">// Modify</a>
  val    <a id="dec:val Hopac.MVar.modifyJob" href="#def:val%20Hopac.MVar.modifyJob">modifyJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val <a id="dec:val Hopac.MVar.tryModifyJob" href="#def:val%20Hopac.MVar.tryModifyJob">tryModifyJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val    <a id="dec:val Hopac.MVar.modifyFun" href="#def:val%20Hopac.MVar.modifyFun">modifyFun</a>: ('x -&gt;      'x * 'y)  -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val <a id="dec:val Hopac.MVar.tryModifyFun" href="#def:val%20Hopac.MVar.tryModifyFun">tryModifyFun</a>: ('x -&gt;      'x * 'y)  -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.BoundedMb" href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; =
  <a id="dec:new Hopac.BoundedMb.new" href="#def:new%20Hopac.BoundedMb.new">new</a>: int -&gt; <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.BoundedMb" href="#def:module%20Hopac.BoundedMb">BoundedMb</a> =
  val <a id="dec:val Hopac.BoundedMb.put" href="#def:val%20Hopac.BoundedMb.put">put</a>: <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.BoundedMb.take" href="#def:val%20Hopac.BoundedMb.take">take</a>: <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Mailbox" href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; =
  inherit <a id="dec:inherit Hopac.Mailbox.Alt" href="#def:inherit%20Hopac.Mailbox.Alt">Alt</a>&lt;'x&gt;
  <a id="dec:new Hopac.Mailbox.new" href="#def:new%20Hopac.Mailbox.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Mailbox" href="#def:module%20Hopac.Mailbox">Mailbox</a> =
  val <a id="dec:val Hopac.Mailbox.send" href="#def:val%20Hopac.Mailbox.send">send</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Mailbox.take" href="#def:val%20Hopac.Mailbox.take">take</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
<span class="spacing">  module <a id="dec:module Hopac.Mailbox.Now" href="#def:module%20Hopac.Mailbox.Now">Now</a> =
    val <a id="dec:val Hopac.Mailbox.Now.send" href="#def:val%20Hopac.Mailbox.Now.send">send</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x -&gt; unit
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Lock" href="#def:type%20Hopac.Lock">Lock</a> =
  <a id="dec:new Hopac.Lock.new" href="#def:new%20Hopac.Lock.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Lock">Lock</a>
</span><span class="spacing">module <a id="dec:module Hopac.Lock" href="#def:module%20Hopac.Lock">Lock</a> =
  val <a id="dec:val Hopac.Lock.duringJob" href="#def:val%20Hopac.Lock.duringJob">duringJob</a>: <a href="#def:type%20Hopac.Lock">Lock</a> -&gt;      <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Lock.duringFun" href="#def:val%20Hopac.Lock.duringFun">duringFun</a>: <a href="#def:type%20Hopac.Lock">Lock</a> -&gt; (unit -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">module <a id="dec:module Hopac.Extensions" href="#def:module%20Hopac.Extensions">Extensions</a> =
<span class="spacing">  module <a id="dec:module Hopac.Extensions.Array" href="#def:module%20Hopac.Extensions.Array">Array</a> =
    val <a id="dec:val Hopac.Extensions.Array.mapJob" href="#def:val%20Hopac.Extensions.Array.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;array&lt;'y&gt;&gt;
    val <a id="dec:val Hopac.Extensions.Array.iterJob" href="#def:val%20Hopac.Extensions.Array.iterJob">iterJob</a>:       ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Extensions.Array.iterJobIgnore" href="#def:val%20Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)    -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Extensions.Seq" href="#def:module%20Hopac.Extensions.Seq">Seq</a> =
    val <a id="dec:val Hopac.Extensions.Seq.foldJob" href="#def:val%20Hopac.Extensions.Seq.foldJob">foldJob</a>:     ('x -&gt; 'y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; 'x -&gt; seq&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Extensions.Seq.foldFromJob" href="#def:val%20Hopac.Extensions.Seq.foldFromJob">foldFromJob</a>: 'x -&gt; ('x -&gt; 'y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; seq&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Extensions.Seq.iterJob" href="#def:val%20Hopac.Extensions.Seq.iterJob">iterJob</a>:       ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Extensions.Seq.iterJobIgnore" href="#def:val%20Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)    -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Extensions.Seq.mapJob" href="#def:val%20Hopac.Extensions.Seq.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'y&gt;&gt;
<span class="spacing">    module <a id="dec:module Hopac.Extensions.Seq.Con" href="#def:module%20Hopac.Extensions.Seq.Con">Con</a> =
      val <a id="dec:val Hopac.Extensions.Seq.Con.iterJob" href="#def:val%20Hopac.Extensions.Seq.Con.iterJob">iterJob</a>:       ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
      val <a id="dec:val Hopac.Extensions.Seq.Con.iterJobIgnore" href="#def:val%20Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)    -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
      val <a id="dec:val Hopac.Extensions.Seq.Con.mapJob" href="#def:val%20Hopac.Extensions.Seq.Con.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'y&gt;&gt;
</span></span><span class="spacing">  module <a id="dec:module Hopac.Extensions.Async" href="#def:module%20Hopac.Extensions.Async">Async</a> =
<span class="spacing">    [&lt;AbstractClass&gt;] 
    type <a id="dec:type Hopac.Extensions.Async.OnWithSchedulerBuilder" href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a> =
      <a id="dec:new Hopac.Extensions.Async.OnWithSchedulerBuilder.new" href="#def:new%20Hopac.Extensions.Async.OnWithSchedulerBuilder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
      abstract <a id="dec:abstract Hopac.Extensions.Async.OnWithSchedulerBuilder.Scheduler" href="#def:abstract%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Scheduler">Scheduler</a>: Scheduler
      abstract <a id="dec:abstract Hopac.Extensions.Async.OnWithSchedulerBuilder.Context" href="#def:abstract%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Context">Context</a>: SynchronizationContext
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Bind" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Bind">Bind</a>:  <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.1.Bind" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.1.Bind">Bind</a>:   <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.2.Bind" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.2.Bind">Bind</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Combine" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Combine">Combine</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt; * <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Delay" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Delay">Delay</a>: (unit -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.For" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Return" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Return">Return</a>: 'x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.ReturnFrom" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.ReturnFrom">ReturnFrom</a>:  <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.1.ReturnFrom" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.1.ReturnFrom">ReturnFrom</a>:   <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.2.ReturnFrom" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.2.ReturnFrom">ReturnFrom</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.TryFinally" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.TryFinally">TryFinally</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * (unit -&gt; unit) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.TryWith" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.TryWith">TryWith</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * (exn -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Using" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Using">Using</a>: 'x * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt; when 'x :&gt; IDisposable
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.While" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.While">While</a>: (unit -&gt; bool) * <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Zero" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Zero">Zero</a>: unit -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
      member <a id="dec:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Run" href="#def:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Run">Run</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</span><span class="spacing">    module <a id="dec:module Hopac.Extensions.Async.Global" href="#def:module%20Hopac.Extensions.Async.Global">Global</a> =
      val <a id="dec:val Hopac.Extensions.Async.Global.onMain" href="#def:val%20Hopac.Extensions.Async.Global.onMain">onMain</a>: unit -&gt; <a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</span>    val <a id="dec:val Hopac.Extensions.Async.setMain" href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a>: SynchronizationContext -&gt; unit
    val <a id="dec:val Hopac.Extensions.Async.getMain" href="#def:val%20Hopac.Extensions.Async.getMain">getMain</a>: unit -&gt; SynchronizationContext
</span>  val <a id="dec:val Hopac.Extensions.asyncOn" href="#def:val%20Hopac.Extensions.asyncOn">asyncOn</a>: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
<span class="spacing">  type <a id="dec:type Hopac.Extensions.Task" href="#def:type%20Hopac.Extensions.Task">Task</a> with
    static member <a id="dec:static member Hopac.Extensions.Task.startJob" href="#def:static%20member%20Hopac.Extensions.Task.startJob">startJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;&gt;
</span>  exception <a id="dec:exception Hopac.Extensions.OnCompleted" href="#def:exception%20Hopac.Extensions.OnCompleted">OnCompleted</a>
<span class="spacing">  type <a id="dec:type Hopac.Extensions.IObservable" href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; with
    member <a id="dec:member Hopac.Extensions.IObservable.onceAltOn" href="#def:member%20Hopac.Extensions.IObservable.onceAltOn">onceAltOn</a>: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Extensions.IObservable.onceAltOnMain" href="#def:member%20Hopac.Extensions.IObservable.onceAltOnMain">onceAltOnMain</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Extensions.IObservable.onceAlt" href="#def:member%20Hopac.Extensions.IObservable.onceAlt">onceAlt</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</span></span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">module <a id="dec:module Hopac.Infixes" href="#def:module%20Hopac.Infixes">Infixes</a> =
  <a id="Hopac.Infixes.query-reply" href="#Hopac.Infixes.query-reply" class="h3">// Query-Reply</a>
  val ( <a id="dec:val Hopac.Infixes.*&lt;+-&gt;=" href="#def:val%20Hopac.Infixes.*&lt;+-&gt;=">*&lt;+-&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt;   (<a href="#def:type%20Hopac.Ch">Ch</a>&lt;'r&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;+-&gt;-" href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt;   (<a href="#def:type%20Hopac.Ch">Ch</a>&lt;'r&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt;      'q)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;-=&gt;=" href="#def:val%20Hopac.Infixes.*&lt;-=&gt;=">*&lt;-=&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt;                  -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;-=&gt;-" href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt;                  -&gt;      'q)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;+=&gt;=" href="#def:val%20Hopac.Infixes.*&lt;+=&gt;=">*&lt;+=&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt;                  -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;+=&gt;-" href="#def:val%20Hopac.Infixes.*&lt;+=&gt;-">*&lt;+=&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt;                  -&gt;      'q)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
  <a id="Hopac.Infixes.message-passing" href="#Hopac.Infixes.message-passing" class="h3">// Message passing</a>
  val ( <a id="dec:val Hopac.Infixes.*&lt;-" href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a>  ):      <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;+" href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a>  ):      <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;=" href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a>  ):    <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;=!" href="#def:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a> ):    <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;&lt;=" href="#def:val%20Hopac.Infixes.*&lt;&lt;=">*&lt;&lt;=</a> ):    <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val ( <a id="dec:val Hopac.Infixes.*&lt;&lt;+" href="#def:val%20Hopac.Infixes.*&lt;&lt;+">*&lt;&lt;+</a> ): <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  <a id="Hopac.Infixes.after-actions" href="#Hopac.Infixes.after-actions" class="h3">// After actions</a>
  val ( <a id="dec:val Hopac.Infixes.^=&gt;" href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a>  ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.^-&gt;" href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a>  ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.^=&gt;." href="#def:val%20Hopac.Infixes.^=&gt;.">^=&gt;.</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;  -&gt;         <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.^-&gt;." href="#def:val%20Hopac.Infixes.^-&gt;.">^-&gt;.</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;  -&gt;             'y   -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.^-&gt;!" href="#def:val%20Hopac.Infixes.^-&gt;!">^-&gt;!</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;  -&gt;             exn  -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
  <a id="Hopac.Infixes.choices" href="#Hopac.Infixes.choices" class="h3">// Choices</a>
  val ( <a id="dec:val Hopac.Infixes.&lt;|&gt;" href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>  ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt;     <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val ( <a id="dec:val Hopac.Infixes.&lt;|&gt;*" href="#def:val%20Hopac.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  val ( <a id="dec:val Hopac.Infixes.&lt;~&gt;" href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>  ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt;     <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val ( <a id="dec:val Hopac.Infixes.&lt;~&gt;*" href="#def:val%20Hopac.Infixes.&lt;~&gt;*">&lt;~&gt;*</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  <a id="Hopac.Infixes.sequencing" href="#Hopac.Infixes.sequencing" class="h3">// Sequencing</a>
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;=" href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>   ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;=*" href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a>  ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-" href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>   ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt;      'y)  -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-*" href="#def:val%20Hopac.Infixes.&gt;&gt;-*">&gt;&gt;-*</a>  ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;=." href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a>  ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;         <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;  -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;=*." href="#def:val%20Hopac.Infixes.&gt;&gt;=*.">&gt;&gt;=*.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;         <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;  -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-." href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>  ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;             'y   -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-*." href="#def:val%20Hopac.Infixes.&gt;&gt;-*.">&gt;&gt;-*.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;             'y   -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-!" href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a>  ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;             exn  -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;&gt;-*!" href="#def:val%20Hopac.Infixes.&gt;&gt;-*!">&gt;&gt;-*!</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;  -&gt;             exn  -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;_&gt;
  <a id="Hopac.Infixes.composition" href="#Hopac.Infixes.composition" class="h3">// Composition</a>
  val ( <a id="dec:val Hopac.Infixes.&gt;=&gt;" href="#def:val%20Hopac.Infixes.&gt;=&gt;">&gt;=&gt;</a>   ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;) -&gt; 'x -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;=&gt;*" href="#def:val%20Hopac.Infixes.&gt;=&gt;*">&gt;=&gt;*</a>  ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;" href="#def:val%20Hopac.Infixes.&gt;-&gt;">&gt;-&gt;</a>   ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt;      'z)  -&gt; 'x -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;*" href="#def:val%20Hopac.Infixes.&gt;-&gt;*">&gt;-&gt;*</a>  ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt;      'z)  -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;=&gt;." href="#def:val%20Hopac.Infixes.&gt;=&gt;.">&gt;=&gt;.</a>  ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;         <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;  -&gt; 'x -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;=&gt;*." href="#def:val%20Hopac.Infixes.&gt;=&gt;*.">&gt;=&gt;*.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;         <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;  -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;." href="#def:val%20Hopac.Infixes.&gt;-&gt;.">&gt;-&gt;.</a>  ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;             'z   -&gt; 'x -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;*." href="#def:val%20Hopac.Infixes.&gt;-&gt;*.">&gt;-&gt;*.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;             'z   -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;!" href="#def:val%20Hopac.Infixes.&gt;-&gt;!">&gt;-&gt;!</a>  ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;             exn  -&gt; 'x -&gt;     <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
  val ( <a id="dec:val Hopac.Infixes.&gt;-&gt;*!" href="#def:val%20Hopac.Infixes.&gt;-&gt;*!">&gt;-&gt;*!</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)  -&gt;             exn  -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;_&gt;
  <a id="Hopac.Infixes.pairing" href="#Hopac.Infixes.pairing" class="h3">// Pairing</a>
  val ( <a id="dec:val Hopac.Infixes.&lt;&amp;&gt;" href="#def:val%20Hopac.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&lt;*&gt;" href="#def:val%20Hopac.Infixes.&lt;*&gt;">&lt;*&gt;</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;
  val ( <a id="dec:val Hopac.Infixes.&lt;+&gt;" href="#def:val%20Hopac.Infixes.&lt;+&gt;">&lt;+&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x * 'y&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Proc" href="#def:type%20Hopac.Proc">Proc</a> =
  inherit <a id="dec:inherit Hopac.Proc.Alt" href="#def:inherit%20Hopac.Proc.Alt">Alt</a>&lt;unit&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Proc" href="#def:module%20Hopac.Proc">Proc</a> =
  <a id="Hopac.Proc.spawning-jobs-with-handles" href="#Hopac.Proc.spawning-jobs-with-handles" class="h3">// Spawning jobs with handles</a>
  val <a id="dec:val Hopac.Proc.queue" href="#def:val%20Hopac.Proc.queue">queue</a>:       <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
  val <a id="dec:val Hopac.Proc.queueIgnore" href="#def:val%20Hopac.Proc.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
  val <a id="dec:val Hopac.Proc.start" href="#def:val%20Hopac.Proc.start">start</a>:       <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
  val <a id="dec:val Hopac.Proc.startIgnore" href="#def:val%20Hopac.Proc.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
  <a id="Hopac.Proc.access-to-handle" href="#Hopac.Proc.access-to-handle" class="h3">// Access to handle</a>
  val <a id="dec:val Hopac.Proc.bind" href="#def:val%20Hopac.Proc.bind">bind</a>: (<a href="#def:type%20Hopac.Proc">Proc</a> -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Proc.map" href="#def:val%20Hopac.Proc.map">map</a>: (<a href="#def:type%20Hopac.Proc">Proc</a> -&gt;      'x)  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Proc.self" href="#def:val%20Hopac.Proc.self">self</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
  <a id="Hopac.Proc.joining" href="#Hopac.Proc.joining" class="h3">// Joining</a>
  val <a id="dec:val Hopac.Proc.join" href="#def:val%20Hopac.Proc.join">join</a>: <a href="#def:type%20Hopac.Proc">Proc</a> -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.JobBuilder" href="#def:type%20Hopac.JobBuilder">JobBuilder</a> =
  <a id="dec:new Hopac.JobBuilder.new" href="#def:new%20Hopac.JobBuilder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.JobBuilder">JobBuilder</a>
  member <a id="dec:member Hopac.JobBuilder.Bind" href="#def:member%20Hopac.JobBuilder.Bind">Bind</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  member <a id="dec:member Hopac.JobBuilder.1.Bind" href="#def:member%20Hopac.JobBuilder.1.Bind">Bind</a>:       <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  member <a id="dec:member Hopac.JobBuilder.2.Bind" href="#def:member%20Hopac.JobBuilder.2.Bind">Bind</a>:        <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  member <a id="dec:member Hopac.JobBuilder.3.Bind" href="#def:member%20Hopac.JobBuilder.3.Bind">Bind</a>:         <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
  member <a id="dec:member Hopac.JobBuilder.Combine" href="#def:member%20Hopac.JobBuilder.Combine">Combine</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; * (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.Delay" href="#def:member%20Hopac.JobBuilder.Delay">Delay</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;)
  member <a id="dec:member Hopac.JobBuilder.For" href="#def:member%20Hopac.JobBuilder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  member <a id="dec:member Hopac.JobBuilder.Return" href="#def:member%20Hopac.JobBuilder.Return">Return</a>: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.ReturnFrom" href="#def:member%20Hopac.JobBuilder.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.1.ReturnFrom" href="#def:member%20Hopac.JobBuilder.1.ReturnFrom">ReturnFrom</a>:       <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.2.ReturnFrom" href="#def:member%20Hopac.JobBuilder.2.ReturnFrom">ReturnFrom</a>:        <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.3.ReturnFrom" href="#def:member%20Hopac.JobBuilder.3.ReturnFrom">ReturnFrom</a>:         <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.Run" href="#def:member%20Hopac.JobBuilder.Run">Run</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.TryFinally" href="#def:member%20Hopac.JobBuilder.TryFinally">TryFinally</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) * (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.TryWith" href="#def:member%20Hopac.JobBuilder.TryWith">TryWith</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) * (exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
  member <a id="dec:member Hopac.JobBuilder.Using" href="#def:member%20Hopac.JobBuilder.Using">Using</a>: 'x * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
  member <a id="dec:member Hopac.JobBuilder.While" href="#def:member%20Hopac.JobBuilder.While">While</a>: (unit -&gt; bool) * (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  member <a id="dec:member Hopac.JobBuilder.Zero" href="#def:member%20Hopac.JobBuilder.Zero">Zero</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.EmbeddedJob" href="#def:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt; = struct
    val <a href="#def:type%20Hopac.Job">Job</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    new: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt;
  end
</span><span class="spacing">type <a id="dec:type Hopac.EmbeddedJobBuilder" href="#def:type%20Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a> =
  inherit <a href="#def:type%20Hopac.JobBuilder">JobBuilder</a>
  new: unit -&gt; <a href="#def:type%20Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a>
  member Run: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">type <a id="dec:type Hopac.Scheduler" href="#def:type%20Hopac.Scheduler">Scheduler</a>
</span><span class="spacing">module <a id="dec:module Hopac.Scheduler" href="#def:module%20Hopac.Scheduler">Scheduler</a> =
<span class="spacing">  type <a id="dec:type Hopac.Scheduler.Create" href="#def:type%20Hopac.Scheduler.Create">Create</a> =
    {
      <a id="dec:field Hopac.Scheduler.Create.Foreground" href="#def:field%20Hopac.Scheduler.Create.Foreground">Foreground</a>: option&lt;bool&gt;
      <a id="dec:field Hopac.Scheduler.Create.IdleHandler" href="#def:field%20Hopac.Scheduler.Create.IdleHandler">IdleHandler</a>: option&lt;<a href="#def:type%20Hopac.Job">Job</a>&lt;int&gt;&gt;
      <a id="dec:field Hopac.Scheduler.Create.MaxStackSize" href="#def:field%20Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a>: option&lt;int&gt;
      <a id="dec:field Hopac.Scheduler.Create.NumWorkers" href="#def:field%20Hopac.Scheduler.Create.NumWorkers">NumWorkers</a>: option&lt;int&gt;
      <a id="dec:field Hopac.Scheduler.Create.TopLevelHandler" href="#def:field%20Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a>: option&lt;exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;&gt;
    }
    static member <a id="dec:static member Hopac.Scheduler.Create.Def" href="#def:static%20member%20Hopac.Scheduler.Create.Def">Def</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a>
</span><span class="spacing">  module <a id="dec:module Hopac.Scheduler.Global" href="#def:module%20Hopac.Scheduler.Global">Global</a> =
    val <a id="dec:val Hopac.Scheduler.Global.setCreate" href="#def:val%20Hopac.Scheduler.Global.setCreate">setCreate</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a> -&gt; unit
</span>  val <a id="dec:val Hopac.Scheduler.create" href="#def:val%20Hopac.Scheduler.create">create</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a> -&gt; <a href="#def:type%20Hopac.Scheduler">Scheduler</a>
  val <a id="dec:val Hopac.Scheduler.queue" href="#def:val%20Hopac.Scheduler.queue">queue</a>:       <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
  val <a id="dec:val Hopac.Scheduler.queueIgnore" href="#def:val%20Hopac.Scheduler.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; unit
  val <a id="dec:val Hopac.Scheduler.server" href="#def:val%20Hopac.Scheduler.server">server</a>:      <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; unit
  val <a id="dec:val Hopac.Scheduler.start" href="#def:val%20Hopac.Scheduler.start">start</a>:       <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
  val <a id="dec:val Hopac.Scheduler.startIgnore" href="#def:val%20Hopac.Scheduler.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; unit
  val <a id="dec:val Hopac.Scheduler.startWithActions" href="#def:val%20Hopac.Scheduler.startWithActions">startWithActions</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; (exn -&gt; unit) -&gt; ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; unit
  val <a id="dec:val Hopac.Scheduler.run" href="#def:val%20Hopac.Scheduler.run">run</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; 'x
  val <a id="dec:val Hopac.Scheduler.wait" href="#def:val%20Hopac.Scheduler.wait">wait</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; unit
  val <a id="dec:val Hopac.Scheduler.kill" href="#def:val%20Hopac.Scheduler.kill">kill</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; unit
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">module <a id="dec:module Hopac.Stream" href="#def:module%20Hopac.Stream">Stream</a> =
  <a id="Hopac.Stream.stream-representation" href="#Hopac.Stream.stream-representation" class="h3">// Stream representation</a>
<span class="spacing">  type <a id="dec:type Hopac.Stream.Cons" href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt; =
    | <a id="dec:| Hopac.Stream.Cons.Cons" href="#def:|%20Hopac.Stream.Cons.Cons">Cons</a> of <a href="#def:member%20Hopac.Stream.Property.Value">Value</a>: 'x * Next: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;
    | <a id="dec:| Hopac.Stream.Cons.Nil" href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a>
</span><span class="spacing">  type <a id="dec:type Hopac.Stream.Stream" href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; = <a href="#def:type%20Hopac.Promise">Promise</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;
</span>  <a id="Hopac.Stream.stream-sources-and-variables" href="#Hopac.Stream.stream-sources-and-variables" class="h3">// Stream sources and variables</a>
<span class="spacing">  type <a id="dec:type Hopac.Stream.Src" href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Stream.Src" href="#def:module%20Hopac.Stream.Src">Src</a> =
    val <a id="dec:val Hopac.Stream.Src.create" href="#def:val%20Hopac.Stream.Src.create">create</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Stream.Src.value" href="#def:val%20Hopac.Stream.Src.value">value</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; 'x  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.Src.error" href="#def:val%20Hopac.Stream.Src.error">error</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.Src.close" href="#def:val%20Hopac.Stream.Src.close">close</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt;        -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.Src.tap" href="#def:val%20Hopac.Stream.Src.tap">tap</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span><span class="spacing">  type <a id="dec:type Hopac.Stream.Var" href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Stream.Var" href="#def:module%20Hopac.Stream.Var">Var</a> =
    val <a id="dec:val Hopac.Stream.Var.create" href="#def:val%20Hopac.Stream.Var.create">create</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Stream.Var.get" href="#def:val%20Hopac.Stream.Var.get">get</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; 'x
    val <a id="dec:val Hopac.Stream.Var.set" href="#def:val%20Hopac.Stream.Var.set">set</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.Var.tap" href="#def:val%20Hopac.Stream.Var.tap">tap</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span><span class="spacing">  type <a id="dec:type Hopac.Stream.MVar" href="#def:type%20Hopac.Stream.MVar">MVar</a>&lt;'x&gt;
</span><span class="spacing">  module <a id="dec:module Hopac.Stream.MVar" href="#def:module%20Hopac.Stream.MVar">MVar</a> =
    val <a id="dec:val Hopac.Stream.MVar.create" href="#def:val%20Hopac.Stream.MVar.create">create</a>: 'x -&gt; MVar&lt;'x&gt;
    val <a id="dec:val Hopac.Stream.MVar.get" href="#def:val%20Hopac.Stream.MVar.get">get</a>: MVar&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Stream.MVar.set" href="#def:val%20Hopac.Stream.MVar.set">set</a>: MVar&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.MVar.updateFun" href="#def:val%20Hopac.Stream.MVar.updateFun">updateFun</a>: MVar&lt;'x&gt; -&gt; ('x -&gt;      'x)  -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.MVar.updateJob" href="#def:val%20Hopac.Stream.MVar.updateJob">updateJob</a>: MVar&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
    val <a id="dec:val Hopac.Stream.MVar.tap" href="#def:val%20Hopac.Stream.MVar.tap">tap</a>: MVar&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span><span class="spacing">  type <a id="dec:type Hopac.Stream.Property" href="#def:type%20Hopac.Stream.Property">Property</a>&lt;'x&gt; =
    interface INotifyPropertyChanged
    <a id="dec:new Hopac.Stream.Property.new" href="#def:new%20Hopac.Stream.Property.new">new</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Property">Property</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Property.Value" href="#def:member%20Hopac.Stream.Property.Value">Value</a>: 'x with get, set
    member <a id="dec:member Hopac.Stream.Property.Tap" href="#def:member%20Hopac.Stream.Property.Tap">Tap</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span>  <a id="Hopac.Stream.constructing-streams" href="#Hopac.Stream.constructing-streams" class="h3">// Constructing streams</a>
  val   <a id="dec:val Hopac.Stream.nil" href="#def:val%20Hopac.Stream.nil">nil</a>&lt;'x&gt; : <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.never" href="#def:val%20Hopac.Stream.never">never</a>&lt;'x&gt; : <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.cons" href="#def:val%20Hopac.Stream.cons">cons</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.delay" href="#def:val%20Hopac.Stream.delay">delay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Stream.error" href="#def:val%20Hopac.Stream.error">error</a>: exn -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val    <a id="dec:val Hopac.Stream.one" href="#def:val%20Hopac.Stream.one">one</a>: 'x  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.repeat" href="#def:val%20Hopac.Stream.repeat">repeat</a>: 'x  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.ofSeq" href="#def:val%20Hopac.Stream.ofSeq">ofSeq</a>: seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.once" href="#def:val%20Hopac.Stream.once">once</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.generating-lazy-streams" href="#Hopac.Stream.generating-lazy-streams" class="h3">// Generating lazy streams</a>
  val <a id="dec:val Hopac.Stream.indefinitely" href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.unfoldJob" href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a>: ('s -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'x * 's&gt;&gt;) -&gt; ('s -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;)
  val <a id="dec:val Hopac.Stream.unfoldFun" href="#def:val%20Hopac.Stream.unfoldFun">unfoldFun</a>: ('s -&gt;      option&lt;'x * 's&gt;)  -&gt; ('s -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;)
<span class="spacing">  [&lt;AbstractClass&gt;] 
  type <a id="dec:type Hopac.Stream.GenerateFuns" href="#def:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt; =
    <a id="dec:new Hopac.Stream.GenerateFuns.new" href="#def:new%20Hopac.Stream.GenerateFuns.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt;
    abstract  <a id="dec:abstract Hopac.Stream.GenerateFuns.While" href="#def:abstract%20Hopac.Stream.GenerateFuns.While">While</a>: 's -&gt; bool
    abstract   <a id="dec:abstract Hopac.Stream.GenerateFuns.Next" href="#def:abstract%20Hopac.Stream.GenerateFuns.Next">Next</a>: 's -&gt; 's
    abstract <a id="dec:abstract Hopac.Stream.GenerateFuns.Select" href="#def:abstract%20Hopac.Stream.GenerateFuns.Select">Select</a>: 's -&gt; 'x
</span>  val <a id="dec:val Hopac.Stream.generateFuns" href="#def:val%20Hopac.Stream.generateFuns">generateFuns</a>: 's -&gt; <a href="#def:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.generateFun" href="#def:val%20Hopac.Stream.generateFun">generateFun</a>: initial: 's
                -&gt; doWhile: ('s -&gt; bool)
                -&gt; doNext: ('s -&gt; 's)
                -&gt; doSelect: ('s -&gt; 'x)
                -&gt; Stream&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.iterateJob" href="#def:val%20Hopac.Stream.iterateJob">iterateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.iterateFun" href="#def:val%20Hopac.Stream.iterateFun">iterateFun</a>: ('x -&gt;      'x)  -&gt; 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.generating-streams-based-on-time" href="#Hopac.Stream.generating-streams-based-on-time" class="h3">// Generating streams based on time</a>
  val <a id="dec:val Hopac.Stream.afterDateTimeOffsets" href="#def:val%20Hopac.Stream.afterDateTimeOffsets">afterDateTimeOffsets</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt;
  val <a id="dec:val Hopac.Stream.afterDateTimeOffset" href="#def:val%20Hopac.Stream.afterDateTimeOffset">afterDateTimeOffset</a>: DateTimeOffset -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt;
  val <a id="dec:val Hopac.Stream.afterTimeSpan" href="#def:val%20Hopac.Stream.afterTimeSpan">afterTimeSpan</a>: TimeSpan -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;unit&gt;
  <a id="Hopac.Stream.sampling-live-streams" href="#Hopac.Stream.sampling-live-streams" class="h3">// Sampling live streams</a>
  val <a id="dec:val Hopac.Stream.shift" href="#def:val%20Hopac.Stream.shift">shift</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.combineLatest" href="#def:val%20Hopac.Stream.combineLatest">combineLatest</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x * 'y&gt;
  val <a id="dec:val Hopac.Stream.debounce" href="#def:val%20Hopac.Stream.debounce">debounce</a>: timeout: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.ignoreUntil" href="#def:val%20Hopac.Stream.ignoreUntil">ignoreUntil</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.ignoreWhile" href="#def:val%20Hopac.Stream.ignoreWhile">ignoreWhile</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.samplesBefore" href="#def:val%20Hopac.Stream.samplesBefore">samplesBefore</a>: ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.samplesAfter" href="#def:val%20Hopac.Stream.samplesAfter">samplesAfter</a>:  ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.skipUntil" href="#def:val%20Hopac.Stream.skipUntil">skipUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.takeUntil" href="#def:val%20Hopac.Stream.takeUntil">takeUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.takeAndSkipUntil" href="#def:val%20Hopac.Stream.takeAndSkipUntil">takeAndSkipUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.lazifying-live-streams" href="#Hopac.Stream.lazifying-live-streams" class="h3">// Lazifying live streams</a>
<span class="spacing">  [&lt;AbstractClass&gt;] 
  type <a id="dec:type Hopac.Stream.KeepPrecedingFuns" href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt; =
    <a id="dec:new Hopac.Stream.KeepPrecedingFuns.new" href="#def:new%20Hopac.Stream.KeepPrecedingFuns.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt;
    abstract <a id="dec:abstract Hopac.Stream.KeepPrecedingFuns.First" href="#def:abstract%20Hopac.Stream.KeepPrecedingFuns.First">First</a>: 'x -&gt; 'y
    abstract <a id="dec:abstract Hopac.Stream.KeepPrecedingFuns.Next" href="#def:abstract%20Hopac.Stream.KeepPrecedingFuns.Next">Next</a>: 'y * 'x -&gt; 'y
</span>  val <a id="dec:val Hopac.Stream.keepPrecedingFuns" href="#def:val%20Hopac.Stream.keepPrecedingFuns">keepPrecedingFuns</a>: <a href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.keepPreceding" href="#def:val%20Hopac.Stream.keepPreceding">keepPreceding</a>: maxCount: int -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;Queue&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Stream.keepPreceding1" href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.keepFollowing1" href="#def:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.polling-lazy-streams" href="#Hopac.Stream.polling-lazy-streams" class="h3">// Polling lazy streams</a>
  val  <a id="dec:val Hopac.Stream.afterEach" href="#def:val%20Hopac.Stream.afterEach">afterEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.beforeEach" href="#def:val%20Hopac.Stream.beforeEach">beforeEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Stream.delayEach" href="#def:val%20Hopac.Stream.delayEach">delayEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.pullOn" href="#def:val%20Hopac.Stream.pullOn">pullOn</a>: ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.zip" href="#def:val%20Hopac.Stream.zip">zip</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x * 'y&gt;
  val <a id="dec:val Hopac.Stream.zipWithFun" href="#def:val%20Hopac.Stream.zipWithFun">zipWithFun</a>: ('x -&gt; 'y -&gt; 'z) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
  <a id="Hopac.Stream.interop-with-observables" href="#Hopac.Stream.interop-with-observables" class="h3">// Interop with observables</a>
  val <a id="dec:val Hopac.Stream.ofObservableOn" href="#def:val%20Hopac.Stream.ofObservableOn">ofObservableOn</a>: subscribeOn: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.ofObservableOnMain" href="#def:val%20Hopac.Stream.ofObservableOnMain">ofObservableOnMain</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.ofObservable" href="#def:val%20Hopac.Stream.ofObservable">ofObservable</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.toObservable" href="#def:val%20Hopac.Stream.toObservable">toObservable</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt;
  <a id="Hopac.Stream.mapping-values" href="#Hopac.Stream.mapping-values" class="h3">// Mapping values</a>
  val <a id="dec:val Hopac.Stream.mapJob" href="#def:val%20Hopac.Stream.mapJob">mapJob</a>:                         ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.mapFun" href="#def:val%20Hopac.Stream.mapFun">mapFun</a>:                         ('x -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.mapPipelinedJob" href="#def:val%20Hopac.Stream.mapPipelinedJob">mapPipelinedJob</a>: degree: int -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.mapPipelinedFun" href="#def:val%20Hopac.Stream.mapPipelinedFun">mapPipelinedFun</a>: degree: int -&gt; ('x -&gt;      'y)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.mapConst" href="#def:val%20Hopac.Stream.mapConst">mapConst</a>:                                   'y   -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.mapIgnore" href="#def:val%20Hopac.Stream.mapIgnore">mapIgnore</a>:                                          <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;unit&gt;
  <a id="Hopac.Stream.filtering-by-value" href="#Hopac.Stream.filtering-by-value" class="h3">// Filtering by value</a>
  val <a id="dec:val Hopac.Stream.chooseJob" href="#def:val%20Hopac.Stream.chooseJob">chooseJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.chooseFun" href="#def:val%20Hopac.Stream.chooseFun">chooseFun</a>: ('x -&gt;      option&lt;'y&gt;)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.choose" href="#def:val%20Hopac.Stream.choose">choose</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;option&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.filterJob" href="#def:val%20Hopac.Stream.filterJob">filterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.filterFun" href="#def:val%20Hopac.Stream.filterFun">filterFun</a>: ('x -&gt;      bool)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.grouping-by-value" href="#Hopac.Stream.grouping-by-value" class="h3">// Grouping by value</a>
  val <a id="dec:val Hopac.Stream.groupByJob" href="#def:val%20Hopac.Stream.groupByJob">groupByJob</a>: ('k -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; when 'k: equality
  val <a id="dec:val Hopac.Stream.groupByFun" href="#def:val%20Hopac.Stream.groupByFun">groupByFun</a>: ('k -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt;      'y)  -&gt; ('x -&gt;      'k)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; when 'k: equality
  <a id="Hopac.Stream.buffering-values" href="#Hopac.Stream.buffering-values" class="h3">// Buffering values</a>
  val <a id="dec:val Hopac.Stream.buffer" href="#def:val%20Hopac.Stream.buffer">buffer</a>: int -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;array&lt;'x&gt;&gt;
  <a id="Hopac.Stream.accumulating-state" href="#Hopac.Stream.accumulating-state" class="h3">// Accumulating state</a>
  val     <a id="dec:val Hopac.Stream.scanJob" href="#def:val%20Hopac.Stream.scanJob">scanJob</a>: ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
  val     <a id="dec:val Hopac.Stream.scanFun" href="#def:val%20Hopac.Stream.scanFun">scanFun</a>: ('s -&gt; 'x -&gt;      's)  -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.scanFromJob" href="#def:val%20Hopac.Stream.scanFromJob">scanFromJob</a>: 's -&gt; ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.scanFromFun" href="#def:val%20Hopac.Stream.scanFromFun">scanFromFun</a>: 's -&gt; ('s -&gt; 'x -&gt;      's)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
  <a id="Hopac.Stream.skipping-duplicates" href="#Hopac.Stream.skipping-duplicates" class="h3">// Skipping duplicates</a>
  val <a id="dec:val Hopac.Stream.distinctByJob" href="#def:val%20Hopac.Stream.distinctByJob">distinctByJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
  val <a id="dec:val Hopac.Stream.distinctByFun" href="#def:val%20Hopac.Stream.distinctByFun">distinctByFun</a>: ('x -&gt;      'k)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
  val <a id="dec:val Hopac.Stream.distinctUntilChangedWithJob" href="#def:val%20Hopac.Stream.distinctUntilChangedWithJob">distinctUntilChangedWithJob</a>: ('x -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.distinctUntilChangedWithFun" href="#def:val%20Hopac.Stream.distinctUntilChangedWithFun">distinctUntilChangedWithFun</a>: ('x -&gt; 'x -&gt;      bool)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.distinctUntilChangedByJob" href="#def:val%20Hopac.Stream.distinctUntilChangedByJob">distinctUntilChangedByJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
  val <a id="dec:val Hopac.Stream.distinctUntilChangedByFun" href="#def:val%20Hopac.Stream.distinctUntilChangedByFun">distinctUntilChangedByFun</a>: ('x -&gt;      'k)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
  val <a id="dec:val Hopac.Stream.distinctUntilChanged" href="#def:val%20Hopac.Stream.distinctUntilChanged">distinctUntilChanged</a>:                          <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'x: equality
  <a id="Hopac.Stream.skipping-and-taking-by-value-or-count" href="#Hopac.Stream.skipping-and-taking-by-value-or-count" class="h3">// Skipping and taking by value or count</a>
  val <a id="dec:val Hopac.Stream.skip" href="#def:val%20Hopac.Stream.skip">skip</a>: int64 -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.take" href="#def:val%20Hopac.Stream.take">take</a>: int64 -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.skipWhileJob" href="#def:val%20Hopac.Stream.skipWhileJob">skipWhileJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.skipWhileFun" href="#def:val%20Hopac.Stream.skipWhileFun">skipWhileFun</a>: ('x -&gt;      bool)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.takeWhileJob" href="#def:val%20Hopac.Stream.takeWhileJob">takeWhileJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.takeWhileFun" href="#def:val%20Hopac.Stream.takeWhileFun">takeWhileFun</a>: ('x -&gt;      bool)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.exception-handling" href="#Hopac.Stream.exception-handling" class="h3">// Exception handling</a>
  val <a id="dec:val Hopac.Stream.catch" href="#def:val%20Hopac.Stream.catch">catch</a>: (exn -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.finalization" href="#Hopac.Stream.finalization" class="h3">// Finalization</a>
  val    <a id="dec:val Hopac.Stream.onCloseJob" href="#def:val%20Hopac.Stream.onCloseJob">onCloseJob</a>:      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val    <a id="dec:val Hopac.Stream.onCloseFun" href="#def:val%20Hopac.Stream.onCloseFun">onCloseFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.doFinalizeJob" href="#def:val%20Hopac.Stream.doFinalizeJob">doFinalizeJob</a>:      <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.doFinalizeFun" href="#def:val%20Hopac.Stream.doFinalizeFun">doFinalizeFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  <a id="Hopac.Stream.reducing-stream-to-a-value" href="#Hopac.Stream.reducing-stream-to-a-value" class="h3">// Reducing stream to a value</a>
  val <a id="dec:val Hopac.Stream.count" href="#def:val%20Hopac.Stream.count">count</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;int64&gt;
  val     <a id="dec:val Hopac.Stream.foldJob" href="#def:val%20Hopac.Stream.foldJob">foldJob</a>: ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val     <a id="dec:val Hopac.Stream.foldFun" href="#def:val%20Hopac.Stream.foldFun">foldFun</a>: ('s -&gt; 'x -&gt;      's)  -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.foldFromJob" href="#def:val%20Hopac.Stream.foldFromJob">foldFromJob</a>: 's -&gt; ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.foldFromFun" href="#def:val%20Hopac.Stream.foldFromFun">foldFromFun</a>: 's -&gt; ('s -&gt; 'x -&gt;      's)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val     <a id="dec:val Hopac.Stream.foldBack" href="#def:val%20Hopac.Stream.foldBack">foldBack</a>: ('x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; -&gt; 'sJ) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'sJ -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; when 'sJ :&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.foldFromBack" href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a>: 'sJ -&gt; (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; -&gt; 'x -&gt; 'sJ) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; when 'sJ :&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
  val <a id="dec:val Hopac.Stream.tryPickJob" href="#def:val%20Hopac.Stream.tryPickJob">tryPickJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Stream.tryPickFun" href="#def:val%20Hopac.Stream.tryPickFun">tryPickFun</a>: ('x -&gt;      option&lt;'y&gt;)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;
  <a id="Hopac.Stream.iterating-over-streams" href="#Hopac.Stream.iterating-over-streams" class="h3">// Iterating over streams</a>
  val <a id="dec:val Hopac.Stream.iterJob" href="#def:val%20Hopac.Stream.iterJob">iterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Stream.iterFun" href="#def:val%20Hopac.Stream.iterFun">iterFun</a>: ('x -&gt;      unit)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Stream.iter" href="#def:val%20Hopac.Stream.iter">iter</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Stream.consumeJob" href="#def:val%20Hopac.Stream.consumeJob">consumeJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
  val <a id="dec:val Hopac.Stream.consumeFun" href="#def:val%20Hopac.Stream.consumeFun">consumeFun</a>: ('x -&gt;      unit)  -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
  val <a id="dec:val Hopac.Stream.consume" href="#def:val%20Hopac.Stream.consume">consume</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
  <a id="Hopac.Stream.prefixes-and-suffixes" href="#Hopac.Stream.prefixes-and-suffixes" class="h3">// Prefixes and suffixes</a>
  val <a id="dec:val Hopac.Stream.head" href="#def:val%20Hopac.Stream.head">head</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.tail" href="#def:val%20Hopac.Stream.tail">tail</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.init" href="#def:val%20Hopac.Stream.init">init</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.last" href="#def:val%20Hopac.Stream.last">last</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.inits" href="#def:val%20Hopac.Stream.inits">inits</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Stream.tails" href="#def:val%20Hopac.Stream.tails">tails</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Stream.initsMapFun" href="#def:val%20Hopac.Stream.initsMapFun">initsMapFun</a>: (<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.tailsMapFun" href="#def:val%20Hopac.Stream.tailsMapFun">tailsMapFun</a>: (<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  <a id="Hopac.Stream.joining-lazy-streams" href="#Hopac.Stream.joining-lazy-streams" class="h3">// Joining lazy streams</a>
  val <a id="dec:val Hopac.Stream.append" href="#def:val%20Hopac.Stream.append">append</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.appendAll" href="#def:val%20Hopac.Stream.appendAll">appendAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.appendMap" href="#def:val%20Hopac.Stream.appendMap">appendMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  <a id="Hopac.Stream.joining-live-streams" href="#Hopac.Stream.joining-live-streams" class="h3">// Joining live streams</a>
  val    <a id="dec:val Hopac.Stream.amb" href="#def:val%20Hopac.Stream.amb">amb</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Stream.merge" href="#def:val%20Hopac.Stream.merge">merge</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.switch" href="#def:val%20Hopac.Stream.switch">switch</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.switchTo" href="#def:val%20Hopac.Stream.switchTo">switchTo</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val    <a id="dec:val Hopac.Stream.ambAll" href="#def:val%20Hopac.Stream.ambAll">ambAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val  <a id="dec:val Hopac.Stream.mergeAll" href="#def:val%20Hopac.Stream.mergeAll">mergeAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.switchAll" href="#def:val%20Hopac.Stream.switchAll">switchAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val    <a id="dec:val Hopac.Stream.ambMap" href="#def:val%20Hopac.Stream.ambMap">ambMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val  <a id="dec:val Hopac.Stream.mergeMap" href="#def:val%20Hopac.Stream.mergeMap">mergeMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  val <a id="dec:val Hopac.Stream.switchMap" href="#def:val%20Hopac.Stream.switchMap">switchMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
  <a id="Hopac.Stream.stream-computation-expression-builders" href="#Hopac.Stream.stream-computation-expression-builders" class="h3">// Stream computation expression builders</a>
<span class="spacing">  [&lt;AbstractClass&gt;] 
  type <a id="dec:type Hopac.Stream.Builder" href="#def:type%20Hopac.Stream.Builder">Builder</a> =
    <a id="dec:new Hopac.Stream.Builder.new" href="#def:new%20Hopac.Stream.Builder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
    abstract <a id="dec:abstract Hopac.Stream.Builder.Combine" href="#def:abstract%20Hopac.Stream.Builder.Combine">Combine</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    abstract <a id="dec:abstract Hopac.Stream.Builder.Zero" href="#def:abstract%20Hopac.Stream.Builder.Zero">Zero</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Builder.Bind" href="#def:member%20Hopac.Stream.Builder.Bind">Bind</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
    member <a id="dec:member Hopac.Stream.Builder.Delay" href="#def:member%20Hopac.Stream.Builder.Delay">Delay</a>: (unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Builder.For" href="#def:member%20Hopac.Stream.Builder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
    member <a id="dec:member Hopac.Stream.Builder.TryWith" href="#def:member%20Hopac.Stream.Builder.TryWith">TryWith</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * (exn -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Builder.While" href="#def:member%20Hopac.Stream.Builder.While">While</a>: (unit -&gt; bool) * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Builder.Yield" href="#def:member%20Hopac.Stream.Builder.Yield">Yield</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
    member <a id="dec:member Hopac.Stream.Builder.YieldFrom" href="#def:member%20Hopac.Stream.Builder.YieldFrom">YieldFrom</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span>  val    <a id="dec:val Hopac.Stream.ambed" href="#def:val%20Hopac.Stream.ambed">ambed</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
  val <a id="dec:val Hopac.Stream.appended" href="#def:val%20Hopac.Stream.appended">appended</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
  val   <a id="dec:val Hopac.Stream.merged" href="#def:val%20Hopac.Stream.merged">merged</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
  val <a id="dec:val Hopac.Stream.switched" href="#def:val%20Hopac.Stream.switched">switched</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
  <a id="Hopac.Stream.misc" href="#Hopac.Stream.misc" class="h3">// Misc</a>
  val <a id="dec:val Hopac.Stream.cycle" href="#def:val%20Hopac.Stream.cycle">cycle</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.values" href="#def:val%20Hopac.Stream.values">values</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Stream.joinWith" href="#def:val%20Hopac.Stream.joinWith">joinWith</a>: ('y -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'z&gt;&gt;)               -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
  val  <a id="dec:val Hopac.Stream.mapJoin" href="#def:val%20Hopac.Stream.mapJoin">mapJoin</a>: ('y -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'z&gt;&gt;) -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
  <a id="Hopac.Stream.testing" href="#Hopac.Stream.testing" class="h3">// Testing</a>
  val <a id="dec:val Hopac.Stream.toSeq" href="#def:val%20Hopac.Stream.toSeq">toSeq</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
</span></code></pre>
<pre><code class="fsharp hljs"><span class="spacing">[&lt;AutoOpen&gt;]
module <a id="dec:module Hopac.Hopac" href="#def:module%20Hopac.Hopac">Hopac</a> =
<span class="spacing">  type <a id="dec:type Hopac.Hopac.Stream" href="#def:type%20Hopac.Hopac.Stream">Stream</a>&lt;'x&gt; = <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</span>  <a id="Hopac.Hopac.computation-expression-builders" href="#Hopac.Hopac.computation-expression-builders" class="h3">// Computation expression builders</a>
  val <a id="dec:val Hopac.Hopac.job" href="#def:val%20Hopac.Hopac.job">job</a>: <a href="#def:type%20Hopac.JobBuilder">JobBuilder</a>
  val <a id="dec:val Hopac.Hopac.onMain" href="#def:val%20Hopac.Hopac.onMain">onMain</a>: <a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
  <a id="Hopac.Hopac.spawning-jobs" href="#Hopac.Hopac.spawning-jobs" class="h3">// Spawning jobs</a>
  val <a id="dec:val Hopac.Hopac.queue" href="#def:val%20Hopac.Hopac.queue">queue</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
  val <a id="dec:val Hopac.Hopac.queueIgnore" href="#def:val%20Hopac.Hopac.queueIgnore">queueIgnore</a>:          <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; unit
  val <a id="dec:val Hopac.Hopac.queueDelay" href="#def:val%20Hopac.Hopac.queueDelay">queueDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)   -&gt; unit
  val <a id="dec:val Hopac.Hopac.server" href="#def:val%20Hopac.Hopac.server">server</a>:               <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; unit
  val <a id="dec:val Hopac.Hopac.start" href="#def:val%20Hopac.Hopac.start">start</a>:                <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
  val <a id="dec:val Hopac.Hopac.startIgnore" href="#def:val%20Hopac.Hopac.startIgnore">startIgnore</a>:          <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;    -&gt; unit
  val <a id="dec:val Hopac.Hopac.startDelay" href="#def:val%20Hopac.Hopac.startDelay">startDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;)   -&gt; unit
  val <a id="dec:val Hopac.Hopac.run" href="#def:val%20Hopac.Hopac.run">run</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; 'x
  <a id="Hopac.Hopac.interop" href="#Hopac.Hopac.interop" class="h3">// Interop</a>
  val <a id="dec:val Hopac.Hopac.queueAsTask" href="#def:val%20Hopac.Hopac.queueAsTask">queueAsTask</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Hopac.startAsTask" href="#def:val%20Hopac.Hopac.startAsTask">startAsTask</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Hopac.startWithActions" href="#def:val%20Hopac.Hopac.startWithActions">startWithActions</a>: (exn -&gt; unit) -&gt; ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; unit
  <a id="Hopac.Hopac.timeouts" href="#Hopac.Hopac.timeouts" class="h3">// Timeouts</a>
  val <a id="dec:val Hopac.Hopac.timeOut" href="#def:val%20Hopac.Hopac.timeOut">timeOut</a>:       TimeSpan -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  val <a id="dec:val Hopac.Hopac.timeOutMillis" href="#def:val%20Hopac.Hopac.timeOutMillis">timeOutMillis</a>: int      -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
  <a id="Hopac.Hopac.promises" href="#Hopac.Hopac.promises" class="h3">// Promises</a>
  val <a id="dec:val Hopac.Hopac.memo" href="#def:val%20Hopac.Hopac.memo">memo</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
  <a id="Hopac.Hopac.type-ascription-helpers" href="#Hopac.Hopac.type-ascription-helpers" class="h3">// Type ascription helpers</a>
  val <a id="dec:val Hopac.Hopac.asAlt" href="#def:val%20Hopac.Hopac.asAlt">asAlt</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
  val <a id="dec:val Hopac.Hopac.asJob" href="#def:val%20Hopac.Hopac.asJob">asJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</span></code></pre>
<h2>Description</h2>
<div class="description"><pre><code class="fsharp hljs">namespace <a id="def:namespace Hopac" href="#dec:namespace%20Hopac">Hopac</a>
</code></pre>
<p> Hopac is a library for F# with the aim of making it easier to write correct, modular and efficient parallel, asynchronous, concurrent and reactive programs.  The design of Hopac draws inspiration from languages such as Concurrent ML and Cilk.  Similar to Concurrent ML, Hopac provides message passing primitives and supports the construction of first-class synchronous abstractions, see <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;</code>.  Parallel jobs (lightweight threads) in Hopac are created using techniques similar to the F# Async framework, see <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;</code>.  Hopac runs parallel jobs using a work distributing scheduler in a non-preemptive fashion.  Hopac also includes an implementation of choice streams, see <code class="fsharp hljs"><a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt;</code>, that offers a simple approach to reactive programming.</p>
<p> Before you begin using Hopac, make sure that you have configured your F# interactive and your application to use server garbage collection.  By default, .Net uses single-threaded workstation garbage collection, which makes it impossible for parallel programs to scale.</p>
<p> The documentation of many of the primitives contains a reference implementation.  In most cases, actual implementations are optimized by taking advantage of internal implementation details and may be significantly faster than the reference implementation.  The reference implementations are given for a number of reasons.  First of all, they hopefully help to better understand the semantics of the primitives.  In some cases, the reference implementations also demonstrate how you can interface Hopac with other systems without the need to extend the primitives of Hopac.  The reference implementations can also be seen as examples of how various primitives can be used to implement more complex operations.</p>
<p> Here is a diagram of some of Hopac's types:</p>
<pre><code class="fsharp hljs">                           <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
                            |
                           <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
                            |
      +-------+--------+----+-----+--------+--------+
      |       |        |          |        |        |
     <a href="#def:type%20Hopac.Ch">Ch</a>&lt;_&gt;  <a href="#def:type%20Hopac.Latch">Latch</a>   <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;_&gt;  <a href="#def:type%20Hopac.MVar">MVar</a>&lt;_&gt;  <a href="#def:type%20Hopac.Proc">Proc</a>   <a href="#def:type%20Hopac.Promise">Promise</a>&lt;_&gt;
                                                    |
                                                  <a href="#def:type%20Hopac.IVar">IVar</a>&lt;_&gt;
</code></pre>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Void" href="#dec:type%20Hopac.Void">Void</a>
</code></pre>
<p> A type that has no public constructors to indicate that a job or function does not return normally.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.IAsyncDisposable" href="#dec:type%20Hopac.IAsyncDisposable">IAsyncDisposable</a> =
</code></pre>
<p> An experimental interface for asynchronously disposable resources.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.usingAsync">usingAsync</a></code>.</p>
<p> The point of this interface is that resources using jobs may not be easily synchronously disposable.  Expressing the dispose operation as a job allows the operation to wait for parallel, asynchronous and concurrent operations to complete.</p>
<p> Note that simply calling <code class="fsharp hljs">run&nbsp;(x.<a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a>&nbsp;())</code> defeats the purpose of this interface, unless it is known that the call is not made from a Hopac worker thread and no communication is needed between that thread and the dispose job.</p>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.IAsyncDisposable.DisposeAsync" href="#dec:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that needs to be executed to dispose the resource.  The returned job should wait until the resource is properly disposed.</p>
<p> Note that simply calling <code class="fsharp hljs"><a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a></code> must not immediately dispose the resource.  For example, the following pattern is incorrect:</p>
<pre><code class="fsharp hljs">override this.<a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () = this.DisposeFlag &lt;- true ; Job.unit ()
</code></pre>
<p> A typical correct disposal pattern could look something like this:</p>
<pre><code class="fsharp hljs">override this.<a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () =
  <a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.tryFill">tryFill</a> requestDisposeIVar () <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a>
  completedDisposeIVar
</code></pre>
<p> The above first signals the server to dispose by filling a synchronous variable.  This is non-blocking and does not leak resources.  Then the above waits until the server has signaled that disposal is complete.  If disposal has already been requested, the first operation does nothing. Note that two separate variables are used.</p>
<p> The server loop corresponding to the above could look like this:</p>
<pre><code class="fsharp hljs">let rec serverLoop ... =
  ...
  let disposeAlt () =
    requestDisposeIVar <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> fun () -&gt;
    ...
    completedDisposeIVar <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> ()
  ...
  ... <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> disposeAlt () <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> ...
</code></pre>
<p> In some cases it may be preferable to have the server loop take requests mainly from a single channel (or mailbox):</p>
<pre><code class="fsharp hljs">let rec serverLoop ... =
  requestCh <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> function
    ...
    | RequestDispose -&gt;
      ...
      completedDisposeIVar <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> ()
    ...
</code></pre>
<p> In such a case, one can still use the above two variable disposal pattern by spawning a job that forwards the disposal request to the server request channel before the server loop is started:</p>
<pre><code class="fsharp hljs">requestDisposeIVar <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a> requestCh <a href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a> RequestDispose |&gt; start
</code></pre>
<p> Alternatively, it is usually acceptable to simply send an asynchronous dispose request to the server:</p>
<pre><code class="fsharp hljs">override this.<a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () =
  requestCh <a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> RequestDispose <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a>
  completedDisposeIVar
</code></pre>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Job" href="#dec:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Represents a lightweight thread of execution.</p>
<p> Jobs are defined using expression builders like the <code class="fsharp hljs"><a href="#def:type%20Hopac.JobBuilder">JobBuilder</a></code>, accessible via the <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.job">job</a></code> binding, or using monadic combinators and can then be executed using e.g. <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.run">run</a></code>.</p>
<p> For example, here is a function that creates a job that computes Fibonacci numbers:</p>
<pre><code class="fsharp hljs">let rec fib n = <a href="#def:val%20Hopac.Hopac.job">job</a> {
  if n &lt; 2L then
    return n
  else
    let! (x, y) = fib (n-2L) <a href="#def:val%20Hopac.Infixes.&lt;*&gt;">&lt;*&gt;</a> fib (n-1L)
    return x+y
}
</code></pre>
<p> It can be run, for example, by using the global scheduler:</p>
<pre><code class="fsharp hljs">&gt; fib 30L |&gt; run ;;
val it : int = 832040L
</code></pre>
<p> If you ran the above above examples, you just did the equivalent of running roughly your first million parallel jobs using Hopac.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Job" href="#dec:module%20Hopac.Job">Job</a> =
</code></pre>
<p> Operations on jobs.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.queue" href="#dec:val%20Hopac.Job.queue">queue</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that schedules the given job to be run as a separate concurrent job.  Use <code class="fsharp hljs"><a href="#def:module%20Hopac.Promise">Promise</a>.<a href="#def:val%20Hopac.Promise.queue">queue</a></code> if you need to be able to get the result.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Proc">Proc</a>.<a href="#def:val%20Hopac.Proc.queue">queue</a></code>.</p>
<p> The difference between <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.start">start</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.queue">queue</a></code> is which job, the current job, or the new job, is immediately given control.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.start">start</a></code> queues the current job, while <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.queue">queue</a></code> queues the new job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.start">start</a></code> has slightly lower overhead than <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.queue">queue</a></code> and is likely to be faster in cases where the new job blocks immediately.</p>
<p> For best performance the choice of which operation to use, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.start">start</a></code> or <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.queue">queue</a></code>, depends on the critical path of your system.  It is generally preferable to keep control in the job that is on the critical path.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.queueIgnore" href="#dec:val%20Hopac.Job.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that schedules the given job to be run as a separate concurrent job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.server" href="#dec:val%20Hopac.Job.server">server</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that immediately starts running the given job as a separate concurrent job like <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.start" href="#dec:val%20Hopac.Job.start">start</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that immediately starts running the given job as a separate concurrent job.  Use <code class="fsharp hljs"><a href="#def:module%20Hopac.Promise">Promise</a>.<a href="#def:val%20Hopac.Promise.start">start</a></code> if you need to be able to get the result.  Use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.server">server</a></code> if the job never returns normally.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Proc">Proc</a>.<a href="#def:val%20Hopac.Proc.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.startIgnore" href="#dec:val%20Hopac.Job.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that immediately starts running the given job as a separate concurrent job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.result" href="#dec:val%20Hopac.Job.result">result</a>: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job with the given result.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.lift">lift</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.thunk">thunk</a></code>, <code class="fsharp hljs">unit</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.unit" href="#dec:val%20Hopac.Job.unit">unit</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that does nothing and returns <code class="fsharp hljs">()</code>.  <code class="fsharp hljs">unit&nbsp;()</code> is an optimized version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.result">result</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.bind" href="#dec:val%20Hopac.Job.bind">bind</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that first runs the given job and then passes the result of that job to the given function to build another job which will then be run.  This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a></code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.delayWith" href="#dec:val%20Hopac.Job.delayWith">delayWith</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that calls the given function with the given value to build a job that will then be run.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.delayWith">delayWith</a>&nbsp;x2yJ&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;x2yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.map" href="#dec:val%20Hopac.Job.map">map</a>: ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that runs the given job and maps the result of the job with the given function.  This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a></code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.lift" href="#dec:val%20Hopac.Job.lift">lift</a>: ('x -&gt; 'y) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that calls the given function with the given value to compute the result of the job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.lift">lift</a>&nbsp;x2y&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;x2y</code>.  Note that <code class="fsharp hljs">x2y&nbsp;x&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a></code> is not the same.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.delay" href="#dec:val%20Hopac.Job.delay">delay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that calls the given function to build a job that will then be run.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.delay">delay</a>&nbsp;u2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;u2xJ</code>.</p>
<p> Use of <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.delay">delay</a></code> is often essential for making sure that a job constructed with user-defined code properly captures side-effects performed in the user-defined code or that a job is not constructed too eagerly (e.g. traversing an entire data structure to build a very large job object).  However, it is also the case that there is no need to wrap every constructed job with <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.delay">delay</a></code> and avoiding unnecessary <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.delay">delay</a></code> operations can improve performance.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.thunk" href="#dec:val%20Hopac.Job.thunk">thunk</a>: (unit -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that invokes the given thunk to compute the result of the job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.thunk">thunk</a>&nbsp;u2x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;u2x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.join" href="#dec:val%20Hopac.Job.join">join</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.join">join</a>&nbsp;xJJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.bind">bind</a>&nbsp;id&nbsp;xJJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.abort" href="#dec:val%20Hopac.Job.abort">abort</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> Creates a job that immediately terminates the current job.</p>
<p> Note that when a job aborts, it is considered to be equivalent to having the job block indefinitely and the job will be garbage collected.  This also means that the job neither returns succesfully nor fails with an exception.  This can sometimes be just what you want.  However, in order to execute clean-up operations implemented with <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.using">using</a></code> or <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> or <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a></code>, the job must either return normally or raise an exception.  In other words, do not use <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.abort">abort</a></code> in such a case.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Ignore" href="#dec:val%20Hopac.Job.Ignore">Ignore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job like the given job except that the result of the job will be <code class="fsharp hljs">()</code>.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;ignore</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.raises" href="#dec:val%20Hopac.Job.raises">raises</a>: exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> Creates a job that has the effect of raising the specified exception. <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.raises">raises</a>&nbsp;e</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delayWith">delayWith</a>&nbsp;raise&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryIn" href="#dec:val%20Hopac.Job.tryIn">tryIn</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Implements the <code class="fsharp hljs">try-in-unless</code> exception handling construct for jobs. Both of the continuation jobs <code class="fsharp hljs">'x&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for success, and <code class="fsharp hljs">exn&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for failure, are invoked from a tail position.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryInDelay">tryInDelay</a></code>.</p>
<p> Note that the workflow notation of F# does not support this operation.  It only supports the <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryWith">tryWith</a></code> operation.  <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryIn">tryIn</a></code> makes it easier to write exception handling code that has the desired tail-call properties.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryInDelay" href="#dec:val%20Hopac.Job.tryInDelay">tryInDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Implements the <code class="fsharp hljs">try-in-unless</code> exception handling construct for jobs. Both of the continuation jobs <code class="fsharp hljs">'x&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for success, and <code class="fsharp hljs">exn&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for failure, are invoked from a tail position.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryInDelay">tryInDelay</a>&nbsp;u2xJ&nbsp;x2yJ&nbsp;e2yJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryIn">tryIn</a>&nbsp;(<a href="#def:val%20Hopac.Job.delay">delay</a>&nbsp;u2xJ)&nbsp;x2yJ&nbsp;e2yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryWith" href="#dec:val%20Hopac.Job.tryWith">tryWith</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements the try-with exception handling construct for jobs.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.tryWith">tryWith</a> xJ e2xJ = <a href="#def:val%20Hopac.Job.tryIn">tryIn</a> xJ <a href="#def:val%20Hopac.Job.result">result</a> e2xJ
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryWithDelay" href="#dec:val%20Hopac.Job.tryWithDelay">tryWithDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements the try-with exception handling construct for jobs.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryFinallyJob" href="#dec:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for jobs.  The given action, specified as a job, is executed after the job has been run, whether it fails or completes successfully.</p>
<p> Note that the workflow notation of F# does not support this operation.  It only supports the weaker <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> operation.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ uJ =
  <a href="#def:val%20Hopac.Job.tryIn">tryIn</a> xJ
   &lt;| fun x -&gt; uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> x
   &lt;| fun e -&gt; uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a> e
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryFinallyJobDelay" href="#dec:val%20Hopac.Job.tryFinallyJobDelay">tryFinallyJobDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for jobs.  The given action, specified as a job, is executed after the job has been run, whether it fails or completes successfully.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryFinallyFun" href="#dec:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for jobs.  The given action, specified as a function, is executed after the job has been run, whether it fails or completes successfully.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a> xJ u2u =
  <a href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ
   &lt;| <a href="#def:val%20Hopac.Job.thunk">thunk</a> u2u
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.tryFinallyFunDelay" href="#dec:val%20Hopac.Job.tryFinallyFunDelay">tryFinallyFunDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for jobs.  The given action, specified as a function, is executed after the job has been run, whether it fails or completes successfully.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.catch" href="#dec:val%20Hopac.Job.catch">catch</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Choice&lt;'x, exn&gt;&gt;
</code></pre>
<p> Creates a job that runs the given job and results in either the ordinary result of the job or the exception raised by the job.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.catch">catch</a> xJ =
  <a href="#def:val%20Hopac.Job.tryIn">tryIn</a> xJ
   &lt;| <a href="#def:val%20Hopac.Job.lift">lift</a> Choice1Of2
   &lt;| <a href="#def:val%20Hopac.Job.lift">lift</a> Choice2Of2
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.useIn" href="#dec:val%20Hopac.Job.useIn">useIn</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.useIn">useIn</a>&nbsp;x2yJ&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.using">using</a>&nbsp;x&nbsp;x2yJ</code> and can be more convenient to use in pipelines (i.e. <code class="fsharp hljs">x&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.useIn">useIn</a>&nbsp;x2yJ</code>).</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.using" href="#dec:val%20Hopac.Job.using">using</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
</code></pre>
<p> Implements the <code class="fsharp hljs">use</code> construct for jobs.  The <code class="fsharp hljs">Dispose</code> method of the given disposable object is called after running the job constructed with the disposable object.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.abort">abort</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.usingAsync">usingAsync</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.using">using</a> (x: 'x when 'x :&gt; IDisposable) x2yJ =
  <a href="#def:val%20Hopac.Job.tryFinallyFun">tryFinallyFun</a> (<a href="#def:val%20Hopac.Job.delayWith">delayWith</a> x2yJ x) (x :&gt; IDisposable).Dispose
</code></pre>
<p> Note that the <code class="fsharp hljs">Dispose</code> method is not called if the job aborts before returning from the scope of the <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.using">using</a></code> job.  This is not a serious problem, because scoped disposal of managed resources is usually an optimization and unmanaged resources should already be cleaned up by finalizers.  In cases where you need to ensure scoped disposal, make sure that the job does not abort before returning.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.usingAsync" href="#dec:val%20Hopac.Job.usingAsync">usingAsync</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; <a href="#def:type%20Hopac.IAsyncDisposable">IAsyncDisposable</a>
</code></pre>
<p> Implements an experimental <code class="fsharp hljs">use</code> like construct for asynchronously disposable resources.  The <code class="fsharp hljs"><a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a></code> method of the asynchronously disposable resource is called to construct a job that is later used to dispose the resource after the constructed job returns.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.abort">abort</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.using">using</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.usingAsync">usingAsync</a> (x: 'x when 'x :&gt; <a href="#def:type%20Hopac.IAsyncDisposable">IAsyncDisposable</a>) x2yJ =
  <a href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a> &lt;| <a href="#def:val%20Hopac.Job.delayWith">delayWith</a> x2yJ x
   &lt;| x.<a href="#def:abstract%20Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> ()
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forN" href="#dec:val%20Hopac.Job.forN">forN</a>: int -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that runs the given job sequentially the given number of times.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Job.forN">forN</a> n uJ =
  if n &gt; 0 then
    uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun () -&gt; <a href="#def:val%20Hopac.Job.forN">forN</a> (n - 1) uJ
  else
    Job.unit ()
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forNIgnore" href="#dec:val%20Hopac.Job.forNIgnore">forNIgnore</a>: int -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forNIgnore">forNIgnore</a>&nbsp;n&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.forN">forN</a>&nbsp;n</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forUpTo" href="#dec:val%20Hopac.Job.forUpTo">forUpTo</a>: int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forUpTo">forUpTo</a>&nbsp;lo&nbsp;hi&nbsp;i2uJ</code> creates a job that sequentially iterates from <code class="fsharp hljs">lo</code> to <code class="fsharp hljs">hi</code> (inclusive) and calls the given function to construct jobs that will be executed.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Job.forUpTo">forUpTo</a> lo hi i2uJ =
  if lo &lt;= hi then
    i2uJ lo <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun () -&gt; <a href="#def:val%20Hopac.Job.forUpTo">forUpTo</a> (lo + 1) hi i2uJ
  else
    Job.unit ()
</code></pre>
<p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code class="fsharp hljs">for&nbsp;...&nbsp;to&nbsp;...&nbsp;do&nbsp;...</code> loop of the base F# language.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forUpToIgnore" href="#dec:val%20Hopac.Job.forUpToIgnore">forUpToIgnore</a>: int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forUpToIgnore">forUpToIgnore</a>&nbsp;lo&nbsp;hi&nbsp;i2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forUpTo">forUpTo</a>&nbsp;lo&nbsp;hi&nbsp;(i2xJ&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forDownTo" href="#dec:val%20Hopac.Job.forDownTo">forDownTo</a>: int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forDownTo">forDownTo</a>&nbsp;hi&nbsp;lo&nbsp;i2uJ</code> creates a job that sequentially iterates from <code class="fsharp hljs">hi</code> to <code class="fsharp hljs">lo</code> (inclusive) and calls the given function to construct jobs that will be executed.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Job.forDownTo">forDownTo</a> hi lo i2uJ =
  if hi &gt;= lo then
    i2uJ hi <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun () -&gt; <a href="#def:val%20Hopac.Job.forDownTo">forDownTo</a> (hi - 1) lo i2uJ
  else
    Job.unit ()
</code></pre>
<p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code class="fsharp hljs">for&nbsp;...&nbsp;downto&nbsp;...&nbsp;do&nbsp;...</code> loop of the base F# language.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forDownToIgnore" href="#dec:val%20Hopac.Job.forDownToIgnore">forDownToIgnore</a>: int -&gt; int -&gt; (int -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forDownToIgnore">forDownToIgnore</a>&nbsp;hi&nbsp;lo&nbsp;i2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forDownTo">forDownTo</a>&nbsp;hi&nbsp;lo&nbsp;(i2xJ&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.whileDo" href="#dec:val%20Hopac.Job.whileDo">whileDo</a>: (unit -&gt; bool) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whileDo">whileDo</a>&nbsp;u2b&nbsp;uJ</code> creates a job that sequentially executes the <code class="fsharp hljs">uJ</code> job as long as <code class="fsharp hljs">u2b&nbsp;()</code> returns <code class="fsharp hljs">true</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.whileDo">whileDo</a> u2b uJ = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  let rec loop () =
    if u2b () then
      uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> loop
    else
      Job.unit ()
  loop ()
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.whileDoDelay" href="#dec:val%20Hopac.Job.whileDoDelay">whileDoDelay</a>: (unit -&gt; bool) -&gt; (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a>&nbsp;u2b&nbsp;u2xJ</code> creates a job that sequentially constructs a job with <code class="fsharp hljs">u2xJ</code> and executes it as long as <code class="fsharp hljs">u2b&nbsp;()</code> returns <code class="fsharp hljs">true</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.whileDoIgnore" href="#dec:val%20Hopac.Job.whileDoIgnore">whileDoIgnore</a>: (unit -&gt; bool) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whileDoIgnore">whileDoIgnore</a>&nbsp;u2b&nbsp;xJ</code> creates a job that sequentially executes the <code class="fsharp hljs">xJ</code> job as long as <code class="fsharp hljs">u2b&nbsp;()</code> returns <code class="fsharp hljs">true</code>.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whileDoIgnore">whileDoIgnore</a>&nbsp;u2b&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.whileDo">whileDo</a>&nbsp;u2b</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.whenDo" href="#dec:val%20Hopac.Job.whenDo">whenDo</a>: bool -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.whenDo">whenDo</a>&nbsp;b&nbsp;uJ</code> is equivalent to <code class="fsharp hljs">if&nbsp;b&nbsp;then&nbsp;uJ&nbsp;else&nbsp;Job.unit&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.forever" href="#dec:val%20Hopac.Job.forever">forever</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> Creates a job that repeats the given job indefinitely.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.foreverServer">foreverServer</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.iterate">iterate</a></code>.</p>
<p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Job.forever">forever</a> uJ = uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun () -&gt; <a href="#def:val%20Hopac.Job.forever">forever</a> uJ
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.foreverIgnore" href="#dec:val%20Hopac.Job.foreverIgnore">foreverIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.foreverIgnore">foreverIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.forever">forever</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.iterate" href="#dec:val%20Hopac.Job.iterate">iterate</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> Creates a job that indefinitely iterates the given job constructor starting with the given value.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.iterateServer">iterateServer</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forever">forever</a></code>.</p>
<p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Job.iterate">iterate</a> x x2xJ =
  x2xJ x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun x -&gt; <a href="#def:val%20Hopac.Job.iterate">iterate</a> x x2xJ
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.foreverServer" href="#dec:val%20Hopac.Job.foreverServer">foreverServer</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that starts a separate server job that repeats the given job indefinitely.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.foreverServer">foreverServer</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.forever">forever</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.server">server</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.iterateServer" href="#dec:val%20Hopac.Job.iterateServer">iterateServer</a>: 'x -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that starts a separate server job that indefinitely iterates the given job constructor starting with the given value.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.iterateServer">iterateServer</a>&nbsp;x&nbsp;x2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.iterate">iterate</a>&nbsp;x&nbsp;x2xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Job.server">server</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.seqCollect" href="#dec:val%20Hopac.Job.seqCollect">seqCollect</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that runs all of the jobs in sequence and returns a list of the results.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqIgnore">seqIgnore</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conCollect">conCollect</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.mapJob">mapJob</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.seqCollect">seqCollect</a> (xJs: seq&lt;<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt;) = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  let xs = ResizeArray&lt;_&gt; ()
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.using">using</a> &lt;| xJs.GetEnumerator () &lt;| fun xJs -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a> xJs.MoveNext &lt;| fun () -&gt;
        xJs.Current <a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> xs.Add
  <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> xs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.conCollect" href="#dec:val%20Hopac.Job.conCollect">conCollect</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that runs all of the jobs as separate concurrent jobs and returns a list of the results.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conIgnore">conIgnore</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqCollect">seqCollect</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.mapJob">mapJob</a></code>.</p>
<p> Note that when multiple jobs raise exceptions, then the created job raises an <code class="fsharp hljs">AggregateException</code>.</p>
<p> Note that this is not optimal for fine-grained parallel execution.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.seqIgnore" href="#dec:val%20Hopac.Job.seqIgnore">seqIgnore</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that runs all of the jobs in sequence.  The results of the jobs are ignored.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqCollect">seqCollect</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conIgnore">conIgnore</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.iterJob">iterJob</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.seqIgnore">seqIgnore</a> (uJs: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;&gt;) = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.using">using</a> &lt;| uJs.GetEnumerator () &lt;| fun uJs -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a> uJs.MoveNext &lt;| fun () -&gt;
    uJs.Current
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.conIgnore" href="#dec:val%20Hopac.Job.conIgnore">conIgnore</a>: seq&lt;#<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish.  The results of the jobs are ignored.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conCollect">conCollect</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqIgnore">seqIgnore</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.iterJob">iterJob</a></code>.</p>
<p> Note that when multiple jobs raise exceptions, then the created job raises an <code class="fsharp hljs">AggregateException</code>.</p>
<p> Note that this is not optimal for fine-grained parallel execution.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromBeginEnd" href="#dec:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a>: doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
               -&gt; doEnd: (IAsyncResult -&gt; 'x)
               -&gt; Job&lt;'x&gt;
</code></pre>
<p> Creates a job that performs the asynchronous operation defined by the given pair of <code class="fsharp hljs">doBegin</code> and <code class="fsharp hljs">doEnd</code> operations.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.fromBeginEnd">fromBeginEnd</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a> doBegin doEnd =
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:module%20Hopac.Job.Scheduler">Scheduler</a>.<a href="#def:val%20Hopac.Job.Scheduler.bind">bind</a> &lt;| fun sr -&gt;
  let xI = <a href="#def:type%20Hopac.IVar">IVar</a> ()
  doBegin &lt;| AsyncCallback (fun ar -&gt;
    Scheduler.<a href="#def:val%20Hopac.Scheduler.start">start</a> sr (try xI <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> doEnd ar with e -&gt; xI <a href="#def:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a> e))
  |&gt; ignore
  xI
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromEndBegin" href="#dec:val%20Hopac.Job.fromEndBegin">fromEndBegin</a>: doEnd: (IAsyncResult -&gt; 'x)
               -&gt; doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
               -&gt; Job&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromEndBegin">fromEndBegin</a>&nbsp;doEnd&nbsp;doBegin</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a>&nbsp;doBegin&nbsp;doEnd</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromContinuations" href="#dec:val%20Hopac.Job.fromContinuations">fromContinuations</a>: (('x -&gt; unit) -&gt; (exn -&gt; unit) -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that starts an asynchronous operation by calling the given function with success and failure continuations of which exactly one must be called once.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromAsync" href="#dec:val%20Hopac.Job.fromAsync">fromAsync</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that starts the given async operation and waits for it to complete.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.fromAsync">fromAsync</a></code>.</p>
<p> Note that the async operation is started on whichever thread (and synchronization context) the job happens to be executed on.  Transfer the async operation explicitly, e.g. by using <code class="fsharp hljs">Async.SwitchToContext</code>, to the desired context when necessary.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.toAsync" href="#dec:val%20Hopac.Job.toAsync">toAsync</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
<p> Creates an async operation that starts the given job and waits for it to complete.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.bindAsync" href="#dec:val%20Hopac.Job.bindAsync">bindAsync</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.bindAsync">bindAsync</a>&nbsp;x2yJ&nbsp;xA</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromAsync">fromAsync</a>&nbsp;xA&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;x2yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromTask" href="#dec:val%20Hopac.Job.fromTask">fromTask</a>: (unit -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that calls the given function to start a task and waits for it to complete.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.fromTask">fromTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.fromUnitTask" href="#dec:val%20Hopac.Job.fromUnitTask">fromUnitTask</a>: (unit -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that calls the given function to start a task and waits for it to complete.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.fromUnitTask">fromUnitTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.liftTask" href="#dec:val%20Hopac.Job.liftTask">liftTask</a>: ('x -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'y&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.liftTask">liftTask</a>&nbsp;x2yT</code> is equivalent to <code class="fsharp hljs">fun&nbsp;x&nbsp;-&gt;&nbsp;<a href="#def:val%20Hopac.Job.fromTask">fromTask</a>&nbsp;&lt;|&nbsp;fun&nbsp;()&nbsp;-&gt;&nbsp;x2yT&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.liftUnitTask" href="#dec:val%20Hopac.Job.liftUnitTask">liftUnitTask</a>: ('x -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.liftUnitTask">liftUnitTask</a>&nbsp;x2uT</code> is equivalent to <code class="fsharp hljs">fun&nbsp;x&nbsp;-&gt;&nbsp;<a href="#def:val%20Hopac.Job.fromUnitTask">fromUnitTask</a>&nbsp;&lt;|&nbsp;fun&nbsp;()&nbsp;-&gt;&nbsp;x2uT&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.awaitTask" href="#dec:val%20Hopac.Job.awaitTask">awaitTask</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that waits for the given task to finish and then returns the result of the task.  Note that this does not start the task.  Make sure that the task is started correctly.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromTask">fromTask</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Job.awaitTask">awaitTask</a> (xT: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;) =
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:module%20Hopac.Job.Scheduler">Scheduler</a>.<a href="#def:val%20Hopac.Job.Scheduler.bind">bind</a> &lt;| fun sr -&gt;
  let xI = <a href="#def:type%20Hopac.IVar">IVar</a> ()
  xT.ContinueWith (Action&lt;Threading.Tasks.<a href="#def:type%20Hopac.Extensions.Task">Task</a>&gt;(fun _ -&gt;
    Scheduler.<a href="#def:val%20Hopac.Scheduler.start">start</a> sr (try xI <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> xT.Result with e -&gt; xI <a href="#def:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a> e)))
  |&gt; ignore
  xI
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.awaitUnitTask" href="#dec:val%20Hopac.Job.awaitUnitTask">awaitUnitTask</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that waits until the given task finishes.  Note that this does not start the task.  Make sure that the task is started correctly. See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromUnitTask">fromUnitTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.bindTask" href="#dec:val%20Hopac.Job.bindTask">bindTask</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.bindTask">bindTask</a>&nbsp;x2yJ&nbsp;xT</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.awaitTask">awaitTask</a>&nbsp;xT&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;x2yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.bindUnitTask" href="#dec:val%20Hopac.Job.bindUnitTask">bindUnitTask</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.bindUnitTask">bindUnitTask</a>&nbsp;u2xJ&nbsp;uT</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.awaitUnitTask">awaitUnitTask</a>&nbsp;uT&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;u2xJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.paranoid" href="#dec:val%20Hopac.Job.paranoid">paranoid</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Given a job, creates a new job that behaves exactly like the given job, except that the new job obviously cannot be directly downcast to the underlying type of the given job.  This operation is provided for debugging purposes.  You can always break abstractions using reflection. See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.paranoid">paranoid</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Job.Scheduler" href="#dec:module%20Hopac.Job.Scheduler">Scheduler</a> =
</code></pre>
<p> Operations for dealing with the scheduler.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Scheduler.bind" href="#dec:val%20Hopac.Job.Scheduler.bind">bind</a>: (Scheduler -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">bind&nbsp;s2xJ</code> creates a job that calls the given job constructor with the scheduler under which the job is being executed.  <code class="fsharp hljs">bind</code> allows interfacing Hopac with existing asynchronous operations that do not fall into a pattern that is already supported explicitly.</p>
<p> Hopac jobs are executed under a scheduler.  In almost all cases the scheduler is the global scheduler, but Hopac also allows local schedulers to be created for special purposes.  A job that is suspended for the duration of an external asynchronous operation should be explicitly resumed on the same scheduler.</p>
<p> Suppose, for example, that some system provides an asynchronous operation with the following signature:</p>
<pre><code class="fsharp hljs">val opWithCallback: Input
                 -&gt; onSuccess: (Output -&gt; unit)
                 -&gt; onFailure: (exn -&gt; unit)
                 -&gt; unit
</code></pre>
<p> We would like to wrap the asynchronous operation as a job with following signature:</p>
<pre><code class="fsharp hljs">val opAsJob: Input -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Output&gt;
</code></pre>
<p> This can be done by using a write once variable, which will be filled with the result of the operation, and using <code class="fsharp hljs">bind</code> to capture the current scheduler:</p>
<pre><code class="fsharp hljs">let opAsJob input = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:module%20Hopac.Job.Scheduler">Scheduler</a>.<a href="#def:val%20Hopac.Job.Scheduler.bind">bind</a> &lt;| fun scheduler -&gt;
  let resultIVar = <a href="#def:type%20Hopac.IVar">IVar</a> ()
  let handleWith fill <a href="#def:val%20Hopac.Job.result">result</a> =
    fill resultIVar <a href="#def:val%20Hopac.Job.result">result</a> |&gt; Scheduler.<a href="#def:val%20Hopac.Scheduler.start">start</a> scheduler
  ioWithCallback input
   &lt;| handleWith <a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.fill">fill</a>
   &lt;| handleWith <a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.fillFailure">fillFailure</a>
  resultIVar
</code></pre>
<p> Note that the <code class="fsharp hljs">Scheduler.<a href="#def:val%20Hopac.Scheduler.start">start</a></code> operation is used to explicitly start the fill operation on the captured scheduler.</p>
<p> There are other similar examples as reference implementations of various Hopac primitives.  See, for example, the reference implementations of <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.awaitTask">awaitTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Scheduler.get" href="#dec:val%20Hopac.Job.Scheduler.get">get</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Scheduler&gt;
</code></pre>
<p> Returns a job that returns the scheduler under which the job is being run.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.Scheduler.get">get</a>&nbsp;()</code> is equivalent to <code class="fsharp hljs">bind&nbsp;<a href="#def:val%20Hopac.Job.result">result</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Scheduler.switchToWorker" href="#dec:val%20Hopac.Job.Scheduler.switchToWorker">switchToWorker</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that ensures that the immediately following operation will be executed on a Hopac worker thread.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Scheduler.isolate" href="#dec:val%20Hopac.Job.Scheduler.isolate">isolate</a>: (unit -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.Scheduler.isolate">isolate</a>&nbsp;u2x</code> is like <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.thunk">thunk</a>&nbsp;u2x</code>, but it is ensured that the blocking invocation of <code class="fsharp hljs">u2x</code> does not prevent scheduling of other work.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Job.Random" href="#dec:module%20Hopac.Job.Random">Random</a> =
</code></pre>
<p> Operations on the built-in pseudo random number generator (PRNG) of Hopac.</p>
<p> Note that every actual Hopac worker thread has its own PRNG state and is initialized with a distinct seed.  However, when you <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.start">start</a></code> or <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.run">run</a></code> jobs from some non worker thread, it is possible that successive executions generate the same sequence of numbers.  In the extremely rare case that could be a problem, use <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.queue">queue</a></code> or <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.Scheduler.switchToWorker">switchToWorker</a></code>.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Random.bind" href="#dec:val%20Hopac.Job.Random.bind">bind</a>: (uint64 -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">bind&nbsp;r2xJ</code> creates a job that calls the given job constructor with a pseudo random 64-bit unsigned integer.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Random.map" href="#dec:val%20Hopac.Job.Random.map">map</a>: (uint64 -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">map&nbsp;r2x</code> is equivalent to <code class="fsharp hljs">bind&nbsp;(r2x&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Job.Random.get" href="#dec:val%20Hopac.Job.Random.get">get</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;uint64&gt;
</code></pre>
<p> Returns a job that generates a pseudo random 64-bit unsigned integer. <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.Random.get">get</a>&nbsp;()</code> is equivalent to <code class="fsharp hljs">bind&nbsp;<a href="#def:val%20Hopac.Job.result">result</a></code>.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Alt" href="#dec:type%20Hopac.Alt">Alt</a>&lt;'x&gt; =
</code></pre>
<p> Represents a first-class selective synchronous operation.</p>
<p> The inspiration for alternatives comes from the events of Concurrent ML. The term ''alternative'' was chosen, because the term ''event'' is already widely used in .Net.</p>
<p> Simpler forms of selective synchronization exists in various languages.  For example, the occam language has an <code class="fsharp hljs">alt</code> statement, the Go language has a <code class="fsharp hljs">select</code> statement and Clojure's core.async has an <code class="fsharp hljs">alt</code> function.  In Hopac and Concurrent ML, selective synchronous operations are not limited to primitive message passing operations (see <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.give">give</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.take">take</a></code>), but are instead first-class values (see <code class="fsharp hljs">choose</code>) and can be extended with user-defined code (see <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.afterJob">afterJob</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>) allowing the encapsulation of concurrent protocols as selective synchronous operations.</p>
<p> The idea of alternatives is to allow one to introduce new selective synchronous operations to be used with non-determinic choice aka <code class="fsharp hljs">choose</code>. Obviously, when you have a concurrent server that responds to some protocol, you don't have to perform the protocol as a selective synchronous operation. However, if you do encapsulate the protocol as a selective synchronous operation, you can then combine the operation with other selective synchronous operations.  That is the essence of Hopac and CML.</p>
<p> If a selective synchronous operation is not committed to then it should have essentially no effect.  In order to create such alternatives, one may take advantage of idempotency, rendezvous and negative acknowledgments.  Here are few rules of thumb:</p>
<p> - If you don't need to send arguments to the server, you can synchronize using a <code class="fsharp hljs">take</code> operation on the server's reply channel.  E.g. an operation to take an element from a concurrent buffer.</p>
<p> - If you don't need a result from the server, aside from acknowledgment that the operation has been performed, you can synchronize using a <code class="fsharp hljs">give</code> operation on the server's request channel.  E.g. an operation to remove a specified element from a concurrent bag.</p>
<p> - If you have an idempotent operation, you can use <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code> to send the arguments and a write once variable to the server and then synchronize using a <code class="fsharp hljs">read</code> operation on the write once variable for the reply.  E.g. request to receive a timeout event.</p>
<p> - If you have a non-idempotent operation, you can use <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> to send the arguments, negative acknowledgment token and a channel to the server and then synchronize using a <code class="fsharp hljs">take</code> operation on the channel for the reply.  See <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> for an illustrative toy example.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Alt.Job" href="#dec:inherit%20Hopac.Alt.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;</code>.  You can use an alternative in any context that requires a job.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Alt" href="#dec:module%20Hopac.Alt">Alt</a> =
</code></pre>
<p> Operations on first-class synchronous operations or alternatives.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.always" href="#dec:val%20Hopac.Alt.always">always</a>: 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is always available and results in the given value.</p>
<p> Note that when there are alternatives immediately available in a choice, the first such alternative will be committed to.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.unit" href="#dec:val%20Hopac.Alt.unit">unit</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Returns an alternative that is always available and results in the unit value.  <code class="fsharp hljs">unit&nbsp;()</code> is an optimized version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.always">always</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.once" href="#dec:val%20Hopac.Alt.once">once</a>: 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Returns an alternative that can be committed to once and that produces the given value.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.once">once</a></code> is basically an optimized version of</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.once">once</a> x =
  let xCh = <a href="#def:type%20Hopac.Ch">Ch</a> ()
  xCh <a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> x |&gt; run
  <a href="#def:val%20Hopac.Alt.paranoid">paranoid</a> xCh
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.never" href="#dec:val%20Hopac.Alt.never">never</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is never available.</p>
<p> Note that synchronizing on <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.never">never</a>&nbsp;()</code>, without other alternatives, is equivalent to performing <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.abort">abort</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.zero" href="#dec:val%20Hopac.Alt.zero">zero</a>: unit -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Returns an alternative that is never available.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.zero">zero</a>&nbsp;()</code> is an optimized version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.never">never</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.Ignore" href="#dec:val%20Hopac.Alt.Ignore">Ignore</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.Ignore">Ignore</a>&nbsp;xA</code> is equivalent to <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.prepareJob" href="#dec:val%20Hopac.Alt.prepareJob">prepareJob</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is computed at instantiation time with the given job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code> allows client-server protocols that do not require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  For example, the given job may create and send a request to a server and then return an alternative that waits for the server's reply.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a> u2xAJ = <a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a> (ignore &gt;&gt; u2xAJ)
</code></pre>
<p> Note that, like with <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>, it is essential to avoid blocking inside <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.prepare" href="#dec:val%20Hopac.Alt.prepare">prepare</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is computed at instantiation time with the given job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepare">prepare</a>&nbsp;xAJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a>&nbsp;&lt;|&nbsp;fun&nbsp;()&nbsp;-&gt;&nbsp;xAJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.prepareFun" href="#dec:val%20Hopac.Alt.prepareFun">prepareFun</a>: (unit -&gt; #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is computed at instantiation time with the given thunk.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a></code> is an optimized weaker form of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code> that can be used when no concurrent operations beyond the returned alternative are required by the encapsulated request protocol.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a> u2xA = <a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a> (u2xA &gt;&gt; <a href="#def:val%20Hopac.Job.result">result</a>)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.withNackJob" href="#dec:val%20Hopac.Alt.withNackJob">withNackJob</a>: (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgment alternative.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackFun">withNackFun</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  The negative acknowledgment alternative will be available in case some other instantiated alternative involved in the choice is committed to instead.</p>
<p> Like <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepare">prepare</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> is typically used to encapsulate the client side operation of a concurrent protocol.  The client side operation typically constructs a request, containing the negative acknowledgment alternative, sends it to a server and then returns an alternative that waits for a rendezvous with the server.  In case the client later commits to some other alternative, the negative acknowledgment token becomes available and the server can also abort the operation.</p>
<p> Here is a simple example of an operation encapsulated using <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>. The idea is that we have a server that maintains a counter.  Clients can request the server to increment the counter by a specific amount and return the incremented counter value.  We further want to make it so that in case the client does not commit to the operation, the counter in the server is not updated.</p>
<p> Here is the server communication channel and the server loop:</p>
<pre><code class="fsharp hljs">let counterServer : <a href="#def:type%20Hopac.Ch">Ch</a>&lt;int * <a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; * <a href="#def:type%20Hopac.Ch">Ch</a>&lt;int&gt;&gt; =
  let reqCh = <a href="#def:type%20Hopac.Ch">Ch</a> ()
  server &lt;&lt; <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.iterate">iterate</a> 0 &lt;| fun oldCounter -&gt;
    reqCh <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun (n, nack, replyCh) -&gt;
    let newCounter = oldCounter + n
    replyCh <a href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a> newCounter <a href="#def:val%20Hopac.Infixes.^-&gt;.">^-&gt;.</a> newCounter <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>
    nack                   <a href="#def:val%20Hopac.Infixes.^-&gt;.">^-&gt;.</a> oldCounter
  reqCh
</code></pre>
<p> Note how the server tries to synchronize on either giving the new counter value to the client or the negative acknowledgment.</p>
<p> Here is the encapsulated client side operation:</p>
<pre><code class="fsharp hljs">let incrementBy n : <a href="#def:type%20Hopac.Alt">Alt</a>&lt;int&gt; = <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a> &lt;| fun nack -&gt;
  let replyCh = <a href="#def:type%20Hopac.Ch">Ch</a> ()
  counterServer <a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> (n, nack, replyCh) <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>
  replyCh
</code></pre>
<p> Note that the above can be expressed more concisely using <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code>.</p>
<p> The client side operation just sends the negative acknowledgment to the server as a part of the request.  It is essential that a synchronous rendezvous via a channel, rather than e.g. a write once variable, is used for the reply.  It is also essential to avoid blocking inside <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>, which is why an asynchronous send is used inside the client side operation.</p>
<p> Note that if an alternative created with <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> is not instantiated, then no negative acknowledgment is created.  For example, given an alternative of the form <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.always">always</a>&nbsp;()&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a>&nbsp;(...)</code> the <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> alternative is never instantiated.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.withNackFun" href="#dec:val%20Hopac.Alt.withNackFun">withNackFun</a>: (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackFun">withNackFun</a>&nbsp;n2xA</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a>&nbsp;(<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.lift">lift</a>&nbsp;n2xA)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.wrapAbortJob" href="#dec:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Returns a new alternative that that makes it so that the given job will be started as a separated concurrent job if the given alternative isn't the one being committed to.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortFun">wrapAbortFun</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> have roughly equivalent expressive power and <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a></code> can be expressed in terms of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>.  Sometimes <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a></code> more directly fits the desired usage than <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> and should be preferred in those cases.  In particular, consider using <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a></code>, when you have an alternative whose implementation is similar to the following reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a> (abortAct: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) (evt: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;) : <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; =
  <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a> &lt;| fun nack -&gt;
  nack <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a> abortAct |&gt; <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a> <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>
  evt
</code></pre>
<p> Historical note: Originally Concurrent ML only provided a corresponding combinator named <code class="fsharp hljs">wrapAbort</code>.  Later Concurrent ML changed to provide only <code class="fsharp hljs">withNack</code> as a primitive, because it is a better fit for most use cases, and <code class="fsharp hljs">wrapAbort</code> could be expressed in terms of it.  Racket only provides <code class="fsharp hljs">withNack</code> and, under Racket's model, <code class="fsharp hljs">withNack</code> cannot be expressed in terms of <code class="fsharp hljs">wrapAbort</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.wrapAbortFun" href="#dec:val%20Hopac.Alt.wrapAbortFun">wrapAbortFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortFun">wrapAbortFun</a>&nbsp;u2u&nbsp;xA</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.wrapAbortJob">wrapAbortJob</a>&nbsp;(<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.thunk">thunk</a>&nbsp;u2u)&nbsp;xA</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.choose" href="#dec:val%20Hopac.Alt.choose">choose</a>: seq&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is available when any one of the given alternatives is.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a></code>.</p>
<p> Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a>&nbsp;[]</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.never">never</a>&nbsp;()</code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.choose">choose</a> xAs = <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a> &lt;| fun () -&gt;
  <a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Stream.foldBack">foldBack</a> (<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>) xAs &lt;| <a href="#def:val%20Hopac.Alt.never">never</a> ()
</code></pre>
<p> Above, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code> has the obvious meaning.  Alternatively we could define <code class="fsharp hljs">xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;xA2</code> to be equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a>&nbsp;[xA1;&nbsp;xA2]</code> and consider <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a></code> as primitive.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.choosy" href="#dec:val%20Hopac.Alt.choosy">choosy</a>: array&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a>&nbsp;xAs</code> (read: choose array) is an optimized version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a>&nbsp;xAs</code> when <code class="fsharp hljs">xAs</code> is an array.  Do not write <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a>&nbsp;(Seq.toArray&nbsp;xAs)</code> instead of <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a>&nbsp;xAs</code> unless the resulting alternative is reused many times.</p>
<p> One dominating cost in .Net is memory allocations.  To choose between various forms of non-determistic choice, the following low level implementation details may be of interest.</p>
<pre><code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a> [| ... |]
</code></pre>
<p> Creation: 1 array + 1 object.  Use: 1 object.  Total cost: 3 allocations.</p>
<pre><code class="fsharp hljs">xA1 <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> xA2
</code></pre>
<p> Creation: 1 object.  Use: 1 object.  Total cost: 2 allocations.</p>
<pre><code class="fsharp hljs">xA1 <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> xA2 <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> xA3
</code></pre>
<p> Creation: 2 objects.  Use: 2 objects.  Total cost: 4 allocations.</p>
<p> If you are choosy, then when choosing between 2 or 3 alternatives, <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a></code> is likely to be fastest.  When choosing between 4 or more alternatives, <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a></code> is likely to be fastest.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.random" href="#dec:val%20Hopac.Alt.random">random</a>: (uint64 -&gt; #<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is computed at instantiation time with the the given function, which will be called with a pseudo random 64-bit unsigned integer.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job.Random">Random</a>.<a href="#def:val%20Hopac.Job.Random.bind">bind</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.chooser" href="#dec:val%20Hopac.Alt.chooser">chooser</a>: seq&lt;#<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.chooser">chooser</a>&nbsp;xAs</code> is like <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choose">choose</a>&nbsp;xAs</code> except that the order in which the alternatives from the sequence are instantiated will be determined at random each time the alternative is used.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a></code>.</p>
<p> Note that randomization only applies to the instantiation order.  It makes no difference after instantiation.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.afterJob" href="#dec:val%20Hopac.Alt.afterJob">afterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative whose result is passed to the given job constructor and processed with the resulting job after the given alternative has been committed to.  This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a></code> with the arguments flipped.</p>
<p> Note that although this operator has a type somewhat similar to a monadic bind operation, alternatives do not form a monad (with the <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.always">always</a></code> alternative constructor).  So called Transactional Events do form a monad, but require a more complex synchronization protocol.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.afterFun" href="#dec:val%20Hopac.Alt.afterFun">afterFun</a>: ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">xA&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Alt.afterFun">afterFun</a>&nbsp;x2y</code> is equivalent to <code class="fsharp hljs">xA&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Alt.afterJob">afterJob</a>&nbsp;(x2y&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)</code>. This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a></code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.raises" href="#dec:val%20Hopac.Alt.raises">raises</a>: exn -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
</code></pre>
<p> Creates an alternative that has the effect of raising the specified exception.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.raises">raises</a>&nbsp;e</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a>&nbsp;&lt;|&nbsp;fun&nbsp;()&nbsp;-&gt;&nbsp;raise&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.tryIn" href="#dec:val%20Hopac.Alt.tryIn">tryIn</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; (exn -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Implements the <code class="fsharp hljs">try-in-unless</code> exception handling construct for alternatives.  Both of the continuation jobs <code class="fsharp hljs">'x&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for success, and <code class="fsharp hljs">exn&nbsp;-&gt;&nbsp;<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;</code>, for failure, are invoked from a tail position.</p>
<p> Exceptions from both before and after the commit point can be handled.  An exception that occurs before a commit point, from the user code in a <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code>, or <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>, results in treating that exception as the commit point.</p>
<p> Note you can also use function or job level exception handling before the commit point within the user code in a <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a></code> or <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.tryFinallyJob" href="#dec:val%20Hopac.Alt.tryFinallyJob">tryFinallyJob</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for alternatives.  The given action, specified as a job, is executed after the alternative has been committed to, whether the alternative fails or completes successfully.  Note that the action is not executed in case the alternative is not committed to.  Use <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> to attach the action to the non-committed case.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.tryFinallyJob">tryFinallyJob</a> xA uJ =
  <a href="#def:val%20Hopac.Alt.tryIn">tryIn</a> xA
   &lt;| fun x -&gt; uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> x
   &lt;| fun e -&gt; uJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a> e
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.tryFinallyFun" href="#dec:val%20Hopac.Alt.tryFinallyFun">tryFinallyFun</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Implements a variation of the <code class="fsharp hljs">try-finally</code> exception handling construct for alternatives.  The given action, specified as a function, is executed after the alternative has been committed to, whether the alternative fails or completes successfully.  Note that the action is not executed in case the alternative is not committed to.  Use <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> to attach the action to the non-committed case.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Alt.tryFinallyFun">tryFinallyFun</a> xA u2u =
  <a href="#def:val%20Hopac.Alt.tryFinallyJob">tryFinallyJob</a> xA
   &lt;| <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.thunk">thunk</a> u2u
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.fromBeginEnd" href="#dec:val%20Hopac.Alt.fromBeginEnd">fromBeginEnd</a>: doBegin: (AsyncCallback * obj -&gt; IAsyncResult)
               -&gt; doEnd: (IAsyncResult -&gt; 'x)
               -&gt; doCancel: (IAsyncResult -&gt; unit)
               -&gt; Alt&lt;'x&gt;
</code></pre>
<p> Creates an alternative that, when instantiated, starts the cancellable asynchronous operation defined by the given <code class="fsharp hljs">doBegin</code>, <code class="fsharp hljs">doEnd</code> and <code class="fsharp hljs">doCancel</code> operations and waits for it to complete, after which the alternative becomes available.  If some other alternative is committed to a in a choice before the operation completes, then the operation is cancelled. See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.fromBeginEnd">fromBeginEnd</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.fromAsync" href="#dec:val%20Hopac.Alt.fromAsync">fromAsync</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that, when instantiated, starts the given cancellable async operation and waits for it to complete, after which the alternative becomes available.  If some other alternative is committed to in a choice before the operation completes, then the operation is cancelled.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.fromAsync">fromAsync</a></code>.</p>
<p> Note that the async operation is started on whichever thread (and synchronization context) the job happens to be executed on.  Transfer the async operation explicitly, e.g. by using <code class="fsharp hljs">Async.SwitchToContext</code>, to the desired context when necessary.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.toAsync" href="#dec:val%20Hopac.Alt.toAsync">toAsync</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
<p> Creates an async operation that starts the given alternative and waits for it to be committed to.  If the async operation is cancelled before the alternative is committed to, an attempt is made to also cancel the alternative by making a cancellation alternative available.  Note that cancellation is not transactional and <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.toAsync">toAsync</a>&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.fromAsync">fromAsync</a></code> is not the identity function.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.toAsync">toAsync</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.fromTask" href="#dec:val%20Hopac.Alt.fromTask">fromTask</a>: (CancellationToken -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that, when instantiated, calls the given function with a cancellation token to start a cancellable task and waits for it to complete, after which the alternative becomes available.  If some other alternative is committed to in a choice before the task completes, then the token will be cancelled.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.fromTask">fromTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.fromUnitTask" href="#dec:val%20Hopac.Alt.fromUnitTask">fromUnitTask</a>: (CancellationToken -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that, when instantiated, calls the given function with a cancellation token to start a cancellable task and waits for it to complete, after which the alternative becomes available.  If some other alternative is committed to in a choice before the task completes, then the token will be cancelled.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.fromUnitTask">fromUnitTask</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Alt.paranoid" href="#dec:val%20Hopac.Alt.paranoid">paranoid</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Given an alternative, creates a new alternative that behaves exactly like the given alternative, except that the new alternative obviously cannot be directly downcast to the underlying type of the given alternative.  This operation is provided for debugging purposes.  You can always break abstractions using reflection.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.paranoid">paranoid</a></code>.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Promise" href="#dec:type%20Hopac.Promise">Promise</a>&lt;'x&gt; =
</code></pre>
<p> Represents a promise to produce a result at some point in the future.</p>
<p> Promises are used when a parallel job is started for the purpose of computing a result.  When multiple parallel jobs need to be started to compute results in parallel in regular patterns, combinators such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;*&gt;">&lt;*&gt;</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.conCollect">conCollect</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.mapJob">mapJob</a></code> may be easier to use and provide improved performance.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Promise.Alt" href="#dec:inherit%20Hopac.Promise.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> and <code class="fsharp hljs">xPr&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Promise">Promise</a>.<a href="#def:val%20Hopac.Promise.read">read</a>&nbsp;xPr</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Promise.new" href="#dec:new%20Hopac.Promise.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> Creates a promise that will never be fulfilled.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Promise.1.new" href="#dec:new%20Hopac.Promise.1.new">new</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> Creates a promise whose value is computed lazily with the given job when an attempt is made to read the promise.  Although the job is not started immediately, the effect is that the delayed job will be run as a separate job, which means it is possible to communicate with it as long the delayed job is started before trying to communicate with it.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.memo">memo</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Promise.2.new" href="#dec:new%20Hopac.Promise.2.new">new</a>: 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> Creates a promise with the given value.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Promise.3.new" href="#dec:new%20Hopac.Promise.3.new">new</a>: exn -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> Creates a promise with the given failure exception.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Promise" href="#dec:module%20Hopac.Promise">Promise</a> =
</code></pre>
<p> Operations on promises.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Promise.queue" href="#dec:val%20Hopac.Promise.queue">queue</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that creates a promise, whose value is computed with the given job, which is scheduled to be run as a separate concurrent job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Promise.start">start</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Promise.start" href="#dec:val%20Hopac.Promise.start">start</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that creates a promise, whose value is computed with the given job, which is immediately started to run as a separate concurrent job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Promise.queue">queue</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Promise.read" href="#dec:val%20Hopac.Promise.read">read</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative for reading the promise.  If the promise was delayed, it is started as a separate job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Promise.Now" href="#dec:module%20Hopac.Promise.Now">Now</a> =
</code></pre>
<p> Immediate or non-workflow operations on promises.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Promise.Now.isFulfilled" href="#dec:val%20Hopac.Promise.Now.isFulfilled">isFulfilled</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; bool
</code></pre>
<p> Returns true iff the given promise has already been fulfilled (either with a value or with a failure).</p>
<p> This operation is mainly provided for advanced uses of promises such as when creating more complex data structures that make internal use of promises.  Using this to poll promises is not generally a good idea.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Promise.Now.get" href="#dec:val%20Hopac.Promise.Now.get">get</a>: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt; -&gt; 'x
</code></pre>
<p> Returns the value or raises the failure exception that the promise has been fulfilled with.  It is considered an error if the promise has not yet been fulfilled.</p>
<p> This operation is mainly provided for advanced uses of promises such as when creating more complex data structures that make internal use of promises.  Using this to poll promises is not generally a good idea.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Ch" href="#dec:type%20Hopac.Ch">Ch</a>&lt;'x&gt; =
</code></pre>
<p> Represents a synchronous channel.</p>
<p> Channels provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.</p>
<p> Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.  When simple rendezvous is not needed in a one-shot communication, a write once variable, <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a></code>, may offer slightly better performance.</p>
<p> Channels are optimized for synchronous message passing, which can often be done without buffering.  Channels also provide an asynchronous <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.send">send</a></code> operation, but in situations where buffering is needed, some other message passing mechanism such as a bounded mailbox, <code class="fsharp hljs"><a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;_&gt;</code>, or unbounded mailbox, <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;_&gt;</code>, may be preferable.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Ch.Alt" href="#dec:inherit%20Hopac.Ch.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> and <code class="fsharp hljs">xCh&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.take">take</a>&nbsp;xCh</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Ch.new" href="#dec:new%20Hopac.Ch.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt;
</code></pre>
<p> Creates a new channel.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Ch" href="#dec:module%20Hopac.Ch">Ch</a> =
</code></pre>
<p> Operations on synchronous channels.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.give" href="#dec:val%20Hopac.Ch.give">give</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.send" href="#dec:val%20Hopac.Ch.send">send</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.</p>
<p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a></code> optimized for buffering.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.take" href="#dec:val%20Hopac.Ch.take">take</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that, at instantiation time, offers to take a value from another job on the given channel, and becomes available when another job offers to give a value.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Ch.Try" href="#dec:module%20Hopac.Ch.Try">Try</a> =
</code></pre>
<p> Polling, or non-blocking, operations on synchronous channels.</p>
<p> Note that polling operations only make sense when the other side of the communication is blocked waiting on the channel.  If both a giver and a taker use polling operations on a channel, it is not guaranteed that communication will ever happen.</p>
<p> Also note that a job that performs arbitrarily many polling operations without blocking should not be used in a cooperative system, like Hopac, because such a job completely uses up a single core and prevents other ready jobs from being executed.  Jobs that perform polling should be designed so that after a finitely many poll operations they will block waiting for communication.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.Try.give" href="#dec:val%20Hopac.Ch.Try.give">give</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;
</code></pre>
<p> Creates a job that attempts to give a value to another job waiting on the given channel.  The result indicates whether a value was given or not.  Note that the other side of the communication must be blocked on the channel for communication to happen.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.Try.take" href="#dec:val%20Hopac.Ch.Try.take">take</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that attempts to take a value from another job waiting on the given channel.  Note that the other side of the communication must be blocked on the channel for communication to happen.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Ch.Now" href="#dec:module%20Hopac.Ch.Now">Now</a> =
</code></pre>
<p> Immediate or non-workflow operations on synchronous channels.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Ch.Now.send" href="#dec:val%20Hopac.Ch.Now.send">send</a>: <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; unit
</code></pre>
<p> Sends the given value to the specified channel.  <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:module%20Hopac.Ch.Now">Now</a>.<a href="#def:val%20Hopac.Ch.Now.send">send</a>&nbsp;xCh&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.send">send</a>&nbsp;xCh&nbsp;x&nbsp;|&gt;&nbsp;TopLevel.start</code>.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.send">send</a></code> instead.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.IVar" href="#dec:type%20Hopac.IVar">IVar</a>&lt;'x&gt; =
</code></pre>
<p> Represents a write once variable.</p>
<p> Write once variables are designed for and most commonly used for getting replies from concurrent servers and asynchronous operations, but can also be useful for other purposes such as for one-shot events and for implementing incremental, but immutable, concurrent data structures.</p>
<p> Because it is common to need to be able to communicate either an expected successful result or an exceptional failure in typical use cases of write once variables, direct mechanisms are provided for both.  The implementation is optimized in such a way that the ability to report an exceptional failure does not add overhead to the expected successful usage scenarios.</p>
<p> Write once variables are lightweight objects and it is typical to always just create a new write once variable when one is needed.  In most cases, a write once variable will be slightly more lightweight than a channel.  This is possible because write once variables do not support simple rendezvous like channels do.  When simple rendezvous is necessary, a channel should be used instead.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.IVar.Promise" href="#dec:inherit%20Hopac.IVar.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;</code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.read">read</a>&nbsp;xI</code> is equivalent to <code class="fsharp hljs">xI&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.IVar.new" href="#dec:new%20Hopac.IVar.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
</code></pre>
<p> Creates a new write once variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.IVar.1.new" href="#dec:new%20Hopac.IVar.1.new">new</a>: 'x -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
</code></pre>
<p> Creates a new write once variable with the given value.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.IVar.2.new" href="#dec:new%20Hopac.IVar.2.new">new</a>: exn -&gt; <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt;
</code></pre>
<p> Creates a new write once variable with the given failure exception.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.IVar" href="#dec:module%20Hopac.IVar">IVar</a> =
</code></pre>
<p> Operations on write once variables.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.fill" href="#dec:val%20Hopac.IVar.fill">fill</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes the given value to the given write once variable.  It is an error to write to a single write once variable more than once.  This assumption may be used to optimize the implementation of <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.fill">fill</a></code> and incorrect usage leads to undefined behavior.</p>
<p> In most use cases of write once variables the write once assumption naturally follows from the property that there is only one concurrent job that may ever write to a particular write once variable.  If that is not the case, then you should likely use some other communication primitive. See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.tryFill">tryFill</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.fillFailure">fillFailure</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.tryFill" href="#dec:val%20Hopac.IVar.tryFill">tryFill</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that tries to write the given value to the given write once variable.  No operation takes place and no error is reported in case the write once variable has already been written to.</p>
<p> In most use cases of write once variables it should be clear that a particular variable is written to at most once, because there is only one specific concurrent job that may write to the variable, and <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.tryFill">tryFill</a></code> should not be used as a substitute for not understanding how the program behaves.  However, in some case it can be convenient to use a write once variable as a single shot event and there may be several concurrent jobs that initially trigger the event.  In such cases, you may use <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.tryFill">tryFill</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.fillFailure" href="#dec:val%20Hopac.IVar.fillFailure">fillFailure</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.IVar.fill">fill</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.tryFillFailure" href="#dec:val%20Hopac.IVar.tryFillFailure">tryFillFailure</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that tries to write the given exception to the given write once variable.  No operation takes place and no error is reported in case the write once variable has already been written to.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.read" href="#dec:val%20Hopac.IVar.read">read</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that becomes available after the write once variable has been written to.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.IVar.Now" href="#dec:module%20Hopac.IVar.Now">Now</a> =
</code></pre>
<p> Immediate or non-workflow operations on write once variables.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.Now.isFull" href="#dec:val%20Hopac.IVar.Now.isFull">isFull</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; bool
</code></pre>
<p> Returns true iff the given write once variable has already been filled (either with a value or with a failure).</p>
<p> This operation is mainly provided for advanced uses of write once variables such as when creating more complex data structures that make internal use of write once variables.  Using this to poll write once variables is not generally a good idea.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.IVar.Now.get" href="#dec:val%20Hopac.IVar.Now.get">get</a>: <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x
</code></pre>
<p> Returns the value or raises the failure exception written to the write once variable.  It is considered an error if the write once variable has not yet been written to.</p>
<p> This operation is mainly provided for advanced uses of write once variables such as when creating more complex data structures that make internal use of write once variables.  Using this to poll write once variables is not generally a good idea.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Latch" href="#dec:type%20Hopac.Latch">Latch</a> =
</code></pre>
<p> Represents a dynamic latch.  Latch is similar to the .Net <code class="fsharp hljs">CountdownEvent</code>.</p>
<p> Latches are used for determining when a finite set of parallel jobs is done. If the size of the set is known a priori, then the latch can be initialized with the size as initial count and then each job just decrements the latch.</p>
<p> If the size is unknown (dynamic), then a latch is initialized with a count of one, the a priori known jobs are queued to the latch and then the latch is decremented.  A queue operation increments the count immediately and decrements the count after the job is finished.</p>
<p> Both a first-order interface, with <code class="fsharp hljs">create</code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Latch.Now.increment">increment</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Latch.decrement">decrement</a></code> operations, and a higher-order interface, with <code class="fsharp hljs"><a href="#def:val%20Hopac.Latch.within">within</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Latch.holding">holding</a></code>, <code class="fsharp hljs">queue</code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Latch.queueAsPromise">queueAsPromise</a></code> operations, are provided for programming with latches.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Latch.Alt" href="#dec:inherit%20Hopac.Latch.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Latch">Latch</a></code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;</code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Latch">Latch</a>.await&nbsp;l</code> is equivalent to <code class="fsharp hljs">l&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Latch.new" href="#dec:new%20Hopac.Latch.new">new</a>: int -&gt; <a href="#def:type%20Hopac.Latch">Latch</a>
</code></pre>
<p> Creates a new latch with the specified initial count.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Latch" href="#dec:module%20Hopac.Latch">Latch</a> =
</code></pre>
<p> Operations on latches.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.await" href="#dec:val%20Hopac.Latch.await">await</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Returns an alternative that becomes available once the latch opens.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.within" href="#dec:val%20Hopac.Latch.within">within</a>: (<a href="#def:type%20Hopac.Latch">Latch</a> -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that creates a new latch, passes it to the given function to create a new job to run and then awaits for the latch to open.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.holding" href="#dec:val%20Hopac.Latch.holding">holding</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that runs the given job holding the specified latch.  Note that the latch is only held while the given job is being run.  See also <code class="fsharp hljs"><a href="#def:module%20Hopac.Latch">Latch</a>.<a href="#def:val%20Hopac.Latch.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.queue" href="#dec:val%20Hopac.Latch.queue">queue</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that queues the given job to run as a separate concurrent job and holds the latch until the queued job either returns or fails with an exception.  See also <code class="fsharp hljs"><a href="#def:module%20Hopac.Latch">Latch</a>.<a href="#def:val%20Hopac.Latch.queueAsPromise">queueAsPromise</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.queueAsPromise" href="#dec:val%20Hopac.Latch.queueAsPromise">queueAsPromise</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that queues the given job to run as a separate concurrent job and holds the latch until the queued job either returns or fails with an exception.  A promise is returned for observing the result or failure of the queued job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.decrement" href="#dec:val%20Hopac.Latch.decrement">decrement</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that explicitly decrements the counter of the latch.  When the counter reaches <code class="fsharp hljs">0</code>, the latch becomes open and operations awaiting the latch are resumed.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Latch.Now" href="#dec:module%20Hopac.Latch.Now">Now</a> =
</code></pre>
<p> Immediate operations on latches.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Latch.Now.increment" href="#dec:val%20Hopac.Latch.Now.increment">increment</a>: <a href="#def:type%20Hopac.Latch">Latch</a> -&gt; unit
</code></pre>
<p> Increments the counter of the latch.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.MVar" href="#dec:type%20Hopac.MVar">MVar</a>&lt;'x&gt; =
</code></pre>
<p> Represents a serialized variable.</p>
<p> A serialized variable can be either empty or full.  When a job makes an attempt to take the value of an empty variable, the job is suspended until some other job fills the variable with a value.  At any one time there should only be at most one job that holds the state to be written to a serialized variable.  If this cannot be guaranteed, in other words, there might be two or more jobs trying to fill a serialized variable, then you should not be using serialized variables.  Indeed, the idea is that access to the state is serialized meaning that one and only one concurrent job has access to the state at any one time.</p>
<p> For example, one could declare a variable holding a shared map:</p>
<pre><code class="fsharp hljs">let sharedMap = <a href="#def:type%20Hopac.MVar">MVar</a> Map.empty
</code></pre>
<p> The map can then be accessed from multiple concurrent jobs, one job at a time, using the <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> operations:</p>
<pre><code class="fsharp hljs"><a href="#def:module%20Hopac.MVar">MVar</a>.<a href="#def:val%20Hopac.MVar.mutateFun">mutateFun</a> (Map.add key <a href="#def:val%20Hopac.Stream.Src.value">value</a>) sharedMap
<a href="#def:module%20Hopac.MVar">MVar</a>.read sharedMap <a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> Map.tryFind key
</code></pre>
<p> Another way to put the idea of serialized variables is that the variable acts as a mechanism for passing a permission token, the value contained by the variable, from one concurrent job to another.  Only the concurrent job that holds the token is allowed to fill the variable.  When used in this way, operations on the variable appear as atomic and access to the state will be serialized.</p>
<p> For example, here is an implementation of a synchronization object similar to the .Net <code class="fsharp hljs">AutoResetEvent</code> using serialized variables:</p>
<pre><code class="fsharp hljs">type AutoResetEvent (<a href="#def:val%20Hopac.Stream.init">init</a>: bool) =
  let set = if <a href="#def:val%20Hopac.Stream.init">init</a> then <a href="#def:type%20Hopac.MVar">MVar</a> (()) else <a href="#def:type%20Hopac.MVar">MVar</a> ()
  let unset = if <a href="#def:val%20Hopac.Stream.init">init</a> then <a href="#def:type%20Hopac.MVar">MVar</a> () else <a href="#def:type%20Hopac.MVar">MVar</a> (())
  member this.Set = unset <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> set <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> <a href="#def:module%20Hopac.MVar">MVar</a>.<a href="#def:val%20Hopac.MVar.fill">fill</a> set
  member this.Wait = set <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> <a href="#def:module%20Hopac.MVar">MVar</a>.<a href="#def:val%20Hopac.MVar.fill">fill</a> unset
</code></pre>
<p> The idea is to use two serialized variables to represent the state of the synchronization object.  At most one of the variables, representing the state of the synchronization object, is full at any time.</p>
<p> In general, aside from a possible initial <code class="fsharp hljs">fill</code> operation, an access to a serialized variable should be of the form <code class="fsharp hljs">take&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;...&nbsp;fill</code> or of the form <code class="fsharp hljs">read</code>.  Note that this follows naturally if you initialize a serialized variable with a value and then use the read, modify and mutate operations. On the other hand, accesses of the form <code class="fsharp hljs">fill</code> and <code class="fsharp hljs">read&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;...&nbsp;fill</code> are unsafe.  A <code class="fsharp hljs">take</code> operation effectively grants permission to the job to access the shared state.  The <code class="fsharp hljs">fill</code> operation then gives that permission to the next job that wants to access the shared state.</p>
<p> WARNING: Unfortunately, <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code>s are easy to use unsafely.  Do not use an <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> to pass information from a client to a server, for example.  Use a <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a></code> or <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a></code> for that.  Note that if you are familiar with the <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> abstraction provided by Concurrent Haskell, then it is important to realize that the semantics and intended usage of Hopac's and Concurrent ML's <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> are quite different.  The <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> of Concurrent Haskell is a bit like a simplified <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a></code> with a buffer of one element and some additional operations. The <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> of Hopac and Concurrent ML does not allow usage as a kind of buffered channel.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.MVar.Alt" href="#dec:inherit%20Hopac.MVar.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> and <code class="fsharp hljs">xM&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.MVar">MVar</a>.<a href="#def:val%20Hopac.MVar.take">take</a>&nbsp;xM</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.MVar.new" href="#dec:new%20Hopac.MVar.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;
</code></pre>
<p> Creates a new serialized variable that is initially empty.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.MVar.1.new" href="#dec:new%20Hopac.MVar.1.new">new</a>: 'x -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;
</code></pre>
<p> Creates a new serialized variable that initially contains the given value.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.MVar" href="#dec:module%20Hopac.MVar">MVar</a> =
</code></pre>
<p> Operations on serialized variables.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.fill" href="#dec:val%20Hopac.MVar.fill">fill</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;&lt;=">*&lt;&lt;=</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.take" href="#dec:val%20Hopac.MVar.take">take</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that becomes available when the variable contains a value and, if committed to, takes the value from the variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.read" href="#dec:val%20Hopac.MVar.read">read</a>: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that becomes available when the variable contains a value and, if committed to, read the value from the variable.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let read xM = <a href="#def:val%20Hopac.MVar.take">take</a> xM <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> fun x -&gt; <a href="#def:val%20Hopac.MVar.fill">fill</a> xM x <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> x
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.mutateJob" href="#dec:val%20Hopac.MVar.mutateJob">mutateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with with the result of performing the given job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.tryMutateJob" href="#dec:val%20Hopac.MVar.tryMutateJob">tryMutateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with with the result of performing the given job. If the job raises an exception, the serialized variable is filled with its original value before propagating the exception.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.mutateFun" href="#dec:val%20Hopac.MVar.mutateFun">mutateFun</a>: ('x -&gt; 'x) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.tryMutateFun" href="#dec:val%20Hopac.MVar.tryMutateFun">tryMutateFun</a>: ('x -&gt; 'x) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given function. If the function raises an exception, the serialized variable is filled with its original value before propagating the exception.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.modifyJob" href="#dec:val%20Hopac.MVar.modifyJob">modifyJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given job.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.MVar.modifyJob">modifyJob</a> (x2xyJ: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;) (xM: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;) =
  xM <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> (x2xyJ <a href="#def:val%20Hopac.Infixes.&gt;=&gt;">&gt;=&gt;</a> fun (x, y) -&gt; <a href="#def:val%20Hopac.MVar.fill">fill</a> xM x <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> y)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.tryModifyJob" href="#dec:val%20Hopac.MVar.tryModifyJob">tryModifyJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given job.  If the job raises an exception, the serialized variable is filled with its original value before propagating the exception.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.modifyFun" href="#dec:val%20Hopac.MVar.modifyFun">modifyFun</a>: ('x -&gt; 'x * 'y) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given function.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.MVar.modifyFun">modifyFun</a> (x2xy: 'x -&gt; 'x * 'y) (xM: <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt;) =
  xM <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> (x2xy &gt;&gt; fun (x, y) -&gt; <a href="#def:val%20Hopac.MVar.fill">fill</a> xM x <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> y)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.MVar.tryModifyFun" href="#dec:val%20Hopac.MVar.tryModifyFun">tryModifyFun</a>: ('x -&gt; 'x * 'y) -&gt; <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given function. If the function raises an exception, the serialized variable is filled with its original value before propagating the exception.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.BoundedMb" href="#dec:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; =
</code></pre>
<p> Represents a bounded synchronous mailbox for many to many communication.</p>
<p> Bounded synchronous mailboxes are a useful tool for coordinating work among co-operating jobs.  They provide slack in the form of buffering between producers and consumers allowing them to proceed in parallel.  They also provide back-pressure in the form of blocking producers when consumers cannot keep up.</p>
<p> In cases where buffering is not necessary, the basic channel primitive, <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a>&lt;_&gt;</code>, should be preferred.  In cases where unbounded buffering is not a problem, the basic mailbox primitive, <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;_&gt;</code>, should be preferred.</p>
<p> At the time of writing, <code class="fsharp hljs"><a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;_&gt;</code> is not implemented as a primitive, but is implemented using other primitives of Hopac, and it is likely that performance can be improved significantly.  If you run into a case where the performance of <code class="fsharp hljs"><a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;_&gt;</code> becomes problematic, please submit an issue.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.BoundedMb.new" href="#dec:new%20Hopac.BoundedMb.new">new</a>: int -&gt; <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt;
</code></pre>
<p> Creates a new bounded mailbox.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.BoundedMb" href="#dec:module%20Hopac.BoundedMb">BoundedMb</a> =
</code></pre>
<p> Operations on bounded synchronous mailboxes.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.BoundedMb.put" href="#dec:val%20Hopac.BoundedMb.put">put</a>: <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Selective synchronous operation to put a message to a bounded mailbox. <code class="fsharp hljs"><a href="#def:val%20Hopac.BoundedMb.put">put</a></code> operations are processed in FIFO order and become enabled as soon as there is room in the bounded buffer.  If the buffer capacity is <code class="fsharp hljs">0</code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.BoundedMb.put">put</a></code> behaves exactly like <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.give">give</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.BoundedMb.take" href="#dec:val%20Hopac.BoundedMb.take">take</a>: <a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Selective synchronous operation to take a message from a bounded mailbox. <code class="fsharp hljs"><a href="#def:val%20Hopac.BoundedMb.take">take</a></code> operations are processed in FIFO order and become enabled as soon as there are messages in the bounded buffer.  If the buffer capacity is <code class="fsharp hljs">0</code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.BoundedMb.take">take</a></code> behaves exactly like <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.take">take</a></code>.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Mailbox" href="#dec:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; =
</code></pre>
<p> Represents an asynchronous, unbounded buffered mailbox.</p>
<p> Compared to channels, mailboxes take more memory when empty, but offer space efficient buffering of messages.  In situations where buffering must be bounded, a bounded mailbox, <code class="fsharp hljs"><a href="#def:type%20Hopac.BoundedMb">BoundedMb</a>&lt;_&gt;</code>, should be preferred.  In situations where buffering is not needed, a channel, <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a>&lt;_&gt;</code>, should be preferred.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Mailbox.Alt" href="#dec:inherit%20Hopac.Mailbox.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt;</code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> and <code class="fsharp hljs">xMb&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Mailbox">Mailbox</a>.<a href="#def:val%20Hopac.Mailbox.take">take</a>&nbsp;xMb</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Mailbox.new" href="#dec:new%20Hopac.Mailbox.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt;
</code></pre>
<p> Creates a new mailbox.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Mailbox" href="#dec:module%20Hopac.Mailbox">Mailbox</a> =
</code></pre>
<p> Operations on buffered mailboxes.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Mailbox.send" href="#dec:val%20Hopac.Mailbox.send">send</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;&lt;+">*&lt;&lt;+</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Mailbox.take" href="#dec:val%20Hopac.Mailbox.take">take</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that becomes available when the mailbox contains at least one value and, if committed to, takes a value from the mailbox.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Mailbox.Now" href="#dec:module%20Hopac.Mailbox.Now">Now</a> =
</code></pre>
<p> Immediate or non-workflow operations on buffered mailboxes.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Mailbox.Now.send" href="#dec:val%20Hopac.Mailbox.Now.send">send</a>: <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x -&gt; unit
</code></pre>
<p> Sends the given value to the specified mailbox.  <code class="fsharp hljs"><a href="#def:module%20Hopac.Mailbox">Mailbox</a>.<a href="#def:module%20Hopac.Mailbox.Now">Now</a>.<a href="#def:val%20Hopac.Mailbox.Now.send">send</a>&nbsp;xMb&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Mailbox">Mailbox</a>.<a href="#def:val%20Hopac.Mailbox.send">send</a>&nbsp;xMb&nbsp;x&nbsp;|&gt;&nbsp;<a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.start">start</a></code>.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Mailbox">Mailbox</a>.<a href="#def:val%20Hopac.Mailbox.send">send</a></code> instead.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Lock" href="#dec:type%20Hopac.Lock">Lock</a> =
</code></pre>
<p> A non-recursive mutual exclusion lock for jobs.</p>
<p> In most cases you should use higher-level message passing primitives such as <code class="fsharp hljs"><a href="#def:type%20Hopac.Ch">Ch</a></code>, <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a></code>, <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> or <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a></code>, but in some cases a simple lock might be more natural to use.</p>
<p> Note that this lock is for synchronizing at the level of jobs.  A job may even block while holding the lock.  For short non-blocking critical sections, native locks (e.g. <code class="fsharp hljs">Monitor</code> and <code class="fsharp hljs">SpinLock</code>), concurrent data structures or interlocked operations should be faster.  On the other hand, suspending and resuming a job is several orders of magnitude faster than suspending and resuming a native thread.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Lock.new" href="#dec:new%20Hopac.Lock.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Lock">Lock</a>
</code></pre>
<p> Creates a new lock.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Lock" href="#dec:module%20Hopac.Lock">Lock</a> =
</code></pre>
<p> Operations on mutual exclusion locks.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Lock.duringJob" href="#dec:val%20Hopac.Lock.duringJob">duringJob</a>: <a href="#def:type%20Hopac.Lock">Lock</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that runs the given job so that the lock is held during the execution of the given job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Lock.duringFun" href="#dec:val%20Hopac.Lock.duringFun">duringFun</a>: <a href="#def:type%20Hopac.Lock">Lock</a> -&gt; (unit -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that calls the given function so that the lock is held during the execution of the function.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions" href="#dec:module%20Hopac.Extensions">Extensions</a> =
</code></pre>
<p> Extensions to various system modules and types for programming with jobs. You can open this module to use the extensions much like as if they were part of the existing modules and types.</p>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions.Array" href="#dec:module%20Hopac.Extensions.Array">Array</a> =
</code></pre>
<p> Operations for processing arrays with jobs.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Array.mapJob" href="#dec:val%20Hopac.Extensions.Array.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;array&lt;'y&gt;&gt;
</code></pre>
<p> Sequentially maps the given job constructor to the elements of the array and returns an array of the results.  <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs</code> is an optimized version of <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;fun&nbsp;ys&nbsp;-&gt;&nbsp;ys.ToArray&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Array.iterJob" href="#dec:val%20Hopac.Extensions.Array.iterJob">iterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Sequentially iterates the given job constructor over the given array. <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.iterJob">iterJob</a>&nbsp;x2uJ&nbsp;xs</code> is an optimized version of <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.iterJob">iterJob</a>&nbsp;x2uJ&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Array.iterJobIgnore" href="#dec:val%20Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; array&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a>&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.iterJob">iterJob</a>&nbsp;(x2yJ&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions.Seq" href="#dec:module%20Hopac.Extensions.Seq">Seq</a> =
</code></pre>
<p> Operations for processing sequences with jobs.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.foldJob" href="#dec:val%20Hopac.Extensions.Seq.foldJob">foldJob</a>: ('x -&gt; 'y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; 'x -&gt; seq&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Sequentially folds the job constructor over the given sequence and returns the result of the fold.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Extensions.Seq.foldJob">foldJob</a> xy2xJ x (ys: seq&lt;'y&gt;) = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.using">using</a> &lt;| ys.GetEnumerator () &lt;| fun ys -&gt;
  let rec loop x =
    if ys.MoveNext () then
      xy2xJ x ys.Current <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> loop
    else
      <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.result">result</a> x
  loop x
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.foldFromJob" href="#dec:val%20Hopac.Extensions.Seq.foldFromJob">foldFromJob</a>: 'x -&gt; ('x -&gt; 'y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; seq&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Extensions.Seq.foldFromJob">foldFromJob</a>&nbsp;x&nbsp;x2y2xJ&nbsp;ys</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Extensions.Seq.foldJob">foldJob</a>&nbsp;x2y2xJ&nbsp;x&nbsp;ys</code> and is often syntactically more convenient.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.iterJob" href="#dec:val%20Hopac.Extensions.Seq.iterJob">iterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Sequentially iterates the given job constructor over the given sequence. See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.iterJob">iterJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqIgnore">seqIgnore</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.mapJob">mapJob</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Extensions.Seq.iterJob">iterJob</a> x2uJ (xs: seq&lt;'x&gt;) = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.using">using</a> &lt;| xs.GetEnumerator () &lt;| fun xs -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a> xs.MoveNext &lt;| fun () -&gt;
    x2uJ xs.Current
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.iterJobIgnore" href="#dec:val%20Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a>&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.iterJob">iterJob</a>&nbsp;(x2yJ&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.mapJob" href="#dec:val%20Hopac.Extensions.Seq.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'y&gt;&gt;
</code></pre>
<p> Sequentially maps the given job constructor to the elements of the sequence and returns a list of the results.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.seqCollect">seqCollect</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.mapJob">mapJob</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Array">Array</a>.<a href="#def:val%20Hopac.Extensions.Array.mapJob">mapJob</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Extensions.Seq.mapJob">mapJob</a> x2yJ (xs: seq&lt;'x&gt;) = <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a> &lt;| fun () -&gt;
  let ys = ResizeArray&lt;_&gt;()
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.using">using</a> &lt;| xs.GetEnumerator () &lt;| fun xs -&gt;
  <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.whileDoDelay">whileDoDelay</a> xs.MoveNext &lt;| fun () -&gt;
        x2yJ xs.Current <a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> ys.Add
  <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> ys
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions.Seq.Con" href="#dec:module%20Hopac.Extensions.Seq.Con">Con</a> =
</code></pre>
<p> Operations for processing sequences using concurrent jobs.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.Con.iterJob" href="#dec:val%20Hopac.Extensions.Seq.Con.iterJob">iterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conIgnore">conIgnore</a></code>.</p>
<p> Note that this is not optimal for fine-grained parallel execution.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.Con.iterJobIgnore" href="#dec:val%20Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a>&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq.Con">Con</a>.<a href="#def:val%20Hopac.Extensions.Seq.Con.iterJob">iterJob</a>&nbsp;(x2yJ&nbsp;&gt;&gt;&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</p>
<p> Note that this is not optimal for fine-grained parallel execution.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Seq.Con.mapJob" href="#dec:val%20Hopac.Extensions.Seq.Con.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'y&gt;&gt;
</code></pre>
<p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished collecting the results into a list.  See also: <code class="fsharp hljs"><a href="#def:module%20Hopac.Extensions.Seq">Seq</a>.<a href="#def:val%20Hopac.Extensions.Seq.mapJob">mapJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.conCollect">conCollect</a></code>.</p>
<p> Note that this is not optimal for fine-grained parallel execution.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions.Async" href="#dec:module%20Hopac.Extensions.Async">Async</a> =
</code></pre>
<p> Operations for interfacing F# async operations with jobs.</p>
<p> Note that these operations are provided for interfacing with existing APIs that work with async operations.  Running async operations within jobs and vice versa incurs potentially significant overheads.</p>
<p> Note that there is almost a one-to-one mapping between async operations and jobs.  The main semantic difference between async operations and Hopac jobs is the threads and schedulers they are being executed on.</p>
<div class="description"><pre><code class="fsharp hljs">[&lt;AbstractClass&gt;] 
type <a id="def:type Hopac.Extensions.Async.OnWithSchedulerBuilder" href="#dec:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a> =
</code></pre>
<p> Builder for async workflows.  The methods in this builder delegate to the default <code class="fsharp hljs">async</code> builder.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Extensions.Async.OnWithSchedulerBuilder.new" href="#dec:new%20Hopac.Extensions.Async.OnWithSchedulerBuilder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Extensions.Async.OnWithSchedulerBuilder.Scheduler" href="#dec:abstract%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Scheduler">Scheduler</a>: Scheduler
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Extensions.Async.OnWithSchedulerBuilder.Context" href="#dec:abstract%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Context">Context</a>: SynchronizationContext
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Bind" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Bind">Bind</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.1.Bind" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.1.Bind">Bind</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.2.Bind" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.2.Bind">Bind</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Combine" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Combine">Combine</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt; * <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Delay" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Delay">Delay</a>: (unit -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.For" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Return" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Return">Return</a>: 'x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.ReturnFrom" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.1.ReturnFrom" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.1.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.2.ReturnFrom" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.2.ReturnFrom">ReturnFrom</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.TryFinally" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.TryFinally">TryFinally</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * (unit -&gt; unit) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.TryWith" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.TryWith">TryWith</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * (exn -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Using" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Using">Using</a>: 'x * ('x -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt;) -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'y&gt; when 'x :&gt; IDisposable
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.While" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.While">While</a>: (unit -&gt; bool) * <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt; -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Zero" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Zero">Zero</a>: unit -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;unit&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.Async.OnWithSchedulerBuilder.Run" href="#dec:member%20Hopac.Extensions.Async.OnWithSchedulerBuilder.Run">Run</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Extensions.Async.Global" href="#dec:module%20Hopac.Extensions.Async.Global">Global</a> =
</code></pre>
<p> Operations on the global scheduler.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Async.Global.onMain" href="#dec:val%20Hopac.Extensions.Async.Global.onMain">onMain</a>: unit -&gt; <a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</code></pre>
<p> Creates a builder for running an async workflow on the main synchronization context and interoperating with the Hopac global scheduler.  The application must call <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a></code> to configure Hopac with the main synchronization context.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Async.setMain" href="#dec:val%20Hopac.Extensions.Async.setMain">setMain</a>: SynchronizationContext -&gt; unit
</code></pre>
<p> Sets the main synchronization context.  This must be called by application code in order to use operations such as <code class="fsharp hljs"><a href="#def:member%20Hopac.Extensions.IObservable.onceAltOnMain">onceAltOnMain</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:val%20Hopac.Hopac.onMain">onMain</a></code></p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.Async.getMain" href="#dec:val%20Hopac.Extensions.Async.getMain">getMain</a>: unit -&gt; SynchronizationContext
</code></pre>
<p> Gets the main synchronization context.  The main synchronization context must be set by application code using <code class="fsharp hljs"><a href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a></code> before calling this function.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Extensions.asyncOn" href="#dec:val%20Hopac.Extensions.asyncOn">asyncOn</a>: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</code></pre>
<p> Builder for an async operation started on the given synchronization context with jobs on the specified scheduler wrapped as a job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Extensions.Task" href="#dec:type%20Hopac.Extensions.Task">Task</a> with
</code></pre>
<p> Operations for interfacing tasks with jobs.</p>
<p> Note that these operations are provided for interfacing with existing APIs that work with tasks.  Starting a job as a task and then awaiting for its result has much higher overhead than simply starting the job as a <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a></code>, for example.</p>
<p> Note that starting tasks correctly can be tricky.  Hopac jobs are designed to be executed by Hopac worker threads, which have the default <code class="fsharp hljs">null</code> synchronization context like the .Net thread pool, but Hopac jobs can also be started on other threads, which may live in non-default synchronization contexts.  Tasks that have been written using the C# async-await mechanism may capture the current synchronization context.  This means that when you call a function to start a task within a Hopac job, you may need to explicitly post that function call to a specific synchronization context.</p>
<p> Note that tasks and jobs are quite different in nature as tasks are comonadic while jobs are monadic.</p>
<div class="description"><pre><code class="fsharp hljs">static member <a id="def:static member Hopac.Extensions.Task.startJob" href="#dec:static%20member%20Hopac.Extensions.Task.startJob">startJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;&gt;
</code></pre>
<p> Creates a job that starts the given job as a separate concurrent job, whose result can be obtained from the returned task.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">exception <a id="def:exception Hopac.Extensions.OnCompleted" href="#dec:exception%20Hopac.Extensions.OnCompleted">OnCompleted</a>
</code></pre>
<p> Raised by <code class="fsharp hljs"><a href="#def:member%20Hopac.Extensions.IObservable.onceAltOn">onceAltOn</a></code> when the associated observable signals the <code class="fsharp hljs"><a href="#def:exception%20Hopac.Extensions.OnCompleted">OnCompleted</a></code> event.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Extensions.IObservable" href="#dec:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; with
</code></pre>
<p> Operations for interfacing Hopac with observables.</p>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.IObservable.onceAltOn" href="#dec:member%20Hopac.Extensions.IObservable.onceAltOn">onceAltOn</a>: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that, when instantiated, subscribes to the observable on the specified synchronization context for at most one event.  Passing <code class="fsharp hljs">null</code> as the synchronization context means that the subscribe and unsubscribe actions are performed on an unspecified thread.</p>
<p> After an <code class="fsharp hljs">OnNext</code> event, the alternative returns the value given by the observable.  After an <code class="fsharp hljs">OnError</code> event, the alternative raises the exception given by the observable.  After an <code class="fsharp hljs"><a href="#def:exception%20Hopac.Extensions.OnCompleted">OnCompleted</a></code> event, the alternative raises the <code class="fsharp hljs"><a href="#def:exception%20Hopac.Extensions.OnCompleted">OnCompleted</a></code> exception.</p>
<p> The alternative becomes available as soon as the observable signals any event after which the alternative unsubscribes from the observable.  If some other alternative is committed to before the observable signals any event, the alternative unsubscribes from the observable.  Note, however, that if the current job explicitly aborts while instantiating some other alternative involved in the same synchronous operation, there is no guarantee that the observable would be unsubscribed from.</p>
<p> Note that, as usual, the alternative can be used many times and even concurrently.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.IObservable.onceAltOnMain" href="#dec:member%20Hopac.Extensions.IObservable.onceAltOnMain">onceAltOnMain</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> This is equivalent to calling <code class="fsharp hljs"><a href="#def:member%20Hopac.Extensions.IObservable.onceAltOn">onceAltOn</a></code> with the main synchronization context.  The application must call <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a></code> to configure Hopac with the main synchronization context.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Extensions.IObservable.onceAlt" href="#dec:member%20Hopac.Extensions.IObservable.onceAlt">onceAlt</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">xO.<a href="#def:member%20Hopac.Extensions.IObservable.onceAlt">onceAlt</a></code> is equivalent to <code class="fsharp hljs">xO.oneAltOn&nbsp;null</code>.  Note that it is often necessary to specify the synchronization context to subscribe on.  See also: <code class="fsharp hljs">Observable.SubscribeOn</code>.</p>
</div>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Infixes" href="#dec:module%20Hopac.Infixes">Infixes</a> =
</code></pre>
<p> Infix operators for concise expression of key Hopac idioms.  You can open this module to bring all of the infix operators into scope.</p>
<p> The operator symbols have been designed to allow the most common expressions to be written without parentheses:</p>
<p> - Message passing operators start with <code class="fsharp hljs">*</code> and have the highest precedence.</p>
<p> - After action operators start with <code class="fsharp hljs">^</code> and have the second highest precedence.</p>
<p> - Choice and pairing operators start with <code class="fsharp hljs">&lt;</code> and have the lowest precedence.</p>
<p> - Sequencing operators start with <code class="fsharp hljs">&gt;</code> and also have the lowest precendence.</p>
<p> Fortunately, sequencing usually follows after choice or pairing, or is inside a function expression, so parentheses are not required in that case.</p>
<p> As an example of operator usage, the <code class="fsharp hljs">swap</code> operation of a swap channel combines message passing, after actions, sequencing and choice:</p>
<pre><code class="fsharp hljs">let swap swapCh outMsg =
      swapCh <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> fun (inMsg, outIv) -&gt; outIv <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> outMsg <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> inMsg
  <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> swapCh <a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a> fun inIv -&gt; (outMsg, inIv)
   :&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
</code></pre>
<p> The type ascription above is unnecessary and is there only as an example of how it can be placed.</p>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;+-&gt;=" href="#dec:val%20Hopac.Infixes.*&lt;+-&gt;=">*&lt;+-&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.Ch">Ch</a>&lt;'r&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given job constructor, constructs a query with a reply channel and a nack, sends it to the query channel and commits on taking the reply from the reply channel.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;=">*&lt;+-&gt;=</a> ) qCh rCh2n2qJ = <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a> &lt;| fun nack -&gt;
  let rCh = <a href="#def:type%20Hopac.Ch">Ch</a>&lt;_&gt; ()
  rCh2n2qJ rCh nack <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun q -&gt;
  qCh <a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> q <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>
  rCh
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;+-&gt;-" href="#dec:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.Ch">Ch</a>&lt;'r&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;unit&gt; -&gt; 'q) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given function, constructs a query with a reply channel and a nack, sends it to the query channel and commits on taking the reply from the reply channel.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code> captures the most common use case of <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> and is a slightly less expressive form of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;=">*&lt;+-&gt;=</a></code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a></code>.</p>
<p> Here is the <code class="fsharp hljs">incrementBy</code> function from the example in <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.withNackJob">withNackJob</a></code> expressed using <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code>:</p>
<pre><code class="fsharp hljs">let incrementBy n =
  counterServer <a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a> fun replyCh nack -&gt; (n, nack, replyCh)
</code></pre>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a> ) qCh rCh2n2q =
  qCh <a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;=">*&lt;+-&gt;=</a> fun rCh n -&gt; rCh2n2q rCh n |&gt; <a href="#def:val%20Hopac.Job.result">result</a>
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;-=&gt;=" href="#dec:val%20Hopac.Infixes.*&lt;-=&gt;=">*&lt;-=&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given job constructor, constructs a query with a reply variable, commits on giving the query and reads the reply variable.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;=">*&lt;-=&gt;=</a> ) qCh rI2qJ = <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a> &lt;| fun () -&gt;
  let rI = <a href="#def:type%20Hopac.IVar">IVar</a>&lt;_&gt; ()
  rI2qJ rI <a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> fun q -&gt;
  qCh <a href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a> q <a href="#def:val%20Hopac.Infixes.^=&gt;.">^=&gt;.</a>
  rI
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;-=&gt;-" href="#dec:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt; -&gt; 'q) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given function, constructs a query with a reply variable, commits on giving the query and reads the reply variable.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a></code> captures the most common use case of <code class="fsharp hljs"><a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.prepareFun">prepareFun</a></code> and is a slighly less expressive form of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;=">*&lt;-=&gt;=</a></code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.*&lt;+-&gt;-">*&lt;+-&gt;-</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;-">*&lt;-=&gt;-</a> ) qCh rI2q = qCh <a href="#def:val%20Hopac.Infixes.*&lt;-=&gt;=">*&lt;-=&gt;=</a> (rI2q &gt;&gt; <a href="#def:val%20Hopac.Job.result">result</a>)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;+=&gt;=" href="#dec:val%20Hopac.Infixes.*&lt;+=&gt;=">*&lt;+=&gt;=</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'q&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given job constructor, constructs a query with a reply variable, sends the query and reads the reply.  In order for the alternative to make sense, the operation must not require exclusive choice.  If this not the case, then the resulting value should only be used as a job.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;+=&gt;=">*&lt;+=&gt;=</a> ) qCh rI2qJ = <a href="#def:module%20Hopac.Alt">Alt</a>.<a href="#def:val%20Hopac.Alt.prepareJob">prepareJob</a> &lt;| fun () -&gt;
  let rI = <a href="#def:type%20Hopac.IVar">IVar</a> ()
  rI2qJ rI <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun q -&gt;
  qCh <a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> q <a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>
  rI
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;+=&gt;-" href="#dec:val%20Hopac.Infixes.*&lt;+=&gt;-">*&lt;+=&gt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'q&gt; -&gt; (<a href="#def:type%20Hopac.IVar">IVar</a>&lt;'r&gt; -&gt; 'q) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'r&gt;
</code></pre>
<p> Creates an alternative that, using the given function, constructs a query with a reply variable, sends the query and reads the reply.  In order for the alternative to make sense, the operation must not require exclusive choice.  If this is not the case, then the resulting value should only be used as a job.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let ( <a href="#def:val%20Hopac.Infixes.*&lt;+=&gt;-">*&lt;+=&gt;-</a> ) qCh rI2q = qCh <a href="#def:val%20Hopac.Infixes.*&lt;+=&gt;=">*&lt;+=&gt;=</a> (rI2q &gt;&gt; <a href="#def:val%20Hopac.Job.result">result</a>)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;-" href="#dec:val%20Hopac.Infixes.*&lt;-">*&lt;-</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.  <code class="fsharp hljs">xCh&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;-">*&lt;-</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.give">give</a>&nbsp;xCh&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;+" href="#dec:val%20Hopac.Infixes.*&lt;+">*&lt;+</a> ): <a href="#def:type%20Hopac.Ch">Ch</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.  <code class="fsharp hljs">xCh&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;+">*&lt;+</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.send">send</a>&nbsp;xCh&nbsp;x</code>.</p>
<p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code class="fsharp hljs"><a href="#def:type%20Hopac.Mailbox">Mailbox</a></code> optimized for buffering.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;=" href="#dec:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> ): <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes to the given write once variable.  It is an error to write to a single <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a></code> more than once.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code class="fsharp hljs">xI&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.fill">fill</a>&nbsp;xI&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;=!" href="#dec:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a> ): <a href="#def:type%20Hopac.IVar">IVar</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code class="fsharp hljs"><a href="#def:type%20Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code class="fsharp hljs">xI&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;=!">*&lt;=!</a>&nbsp;e</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.fillFailure">fillFailure</a>&nbsp;xI&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;&lt;=" href="#dec:val%20Hopac.Infixes.*&lt;&lt;=">*&lt;&lt;=</a> ): <a href="#def:type%20Hopac.MVar">MVar</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code class="fsharp hljs"><a href="#def:type%20Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code class="fsharp hljs">xM&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;&lt;=">*&lt;&lt;=</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.MVar">MVar</a>.<a href="#def:val%20Hopac.MVar.fill">fill</a>&nbsp;xM&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.*&lt;&lt;+" href="#dec:val%20Hopac.Infixes.*&lt;&lt;+">*&lt;&lt;+</a> ): <a href="#def:type%20Hopac.Mailbox">Mailbox</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.  <code class="fsharp hljs">xMb&nbsp;<a href="#def:val%20Hopac.Infixes.*&lt;&lt;+">*&lt;&lt;+</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Mailbox">Mailbox</a>.<a href="#def:val%20Hopac.Mailbox.send">send</a>&nbsp;xMb&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.^=&gt;" href="#dec:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> Creates an alternative whose result is passed to the given job constructor and processed with the resulting job after the given alternative has been committed to.  This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.afterJob">afterJob</a></code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.^-&gt;" href="#dec:val%20Hopac.Infixes.^-&gt;">^-&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a>&nbsp;x2y</code> is equivalent to <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a>&nbsp;(x2y&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)</code>.  This is the same as <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.afterFun">afterFun</a></code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.^=&gt;." href="#dec:val%20Hopac.Infixes.^=&gt;.">^=&gt;.</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^=&gt;.">^=&gt;.</a>&nbsp;yJ</code> is equivalent to <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.^-&gt;." href="#dec:val%20Hopac.Infixes.^-&gt;.">^-&gt;.</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; 'y -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;.">^-&gt;.</a>&nbsp;y</code> is equivalent to <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;y</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.^-&gt;!" href="#dec:val%20Hopac.Infixes.^-&gt;!">^-&gt;!</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt;
</code></pre>
<p> <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;!">^-&gt;!</a>&nbsp;e</code> is equivalent to <code class="fsharp hljs">xA&nbsp;<a href="#def:val%20Hopac.Infixes.^-&gt;">^-&gt;</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;raise&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;|&gt;" href="#dec:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative that is available when either of the given alternatives is available.  <code class="fsharp hljs">xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;xA2</code> is an optimized version of <code class="fsharp hljs">choose&nbsp;[xA1;&nbsp;xA2]</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.choosy">choosy</a></code>.</p>
<p> The given alternatives are processed in a left-to-right order with short-cut evaluation.  In other words, given an alternative of the form <code class="fsharp hljs">first&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;second</code>, the <code class="fsharp hljs">first</code> alternative is first instantiated and, if it is available, is committed to and the <code class="fsharp hljs">second</code> alternative will not be instantiated at all.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;|&gt;*" href="#dec:val%20Hopac.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;~&gt;" href="#dec:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>&nbsp;xA2</code> is like <code class="fsharp hljs">xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;xA2</code> except that the order in which <code class="fsharp hljs">xA1</code> and <code class="fsharp hljs">xA2</code> are instantiated is determined at random every time the alternative is used.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Alt.chooser">chooser</a></code>.</p>
<p> Note that randomization only applies to the instantiation order.  It makes no difference after instantiation.</p>
<p> WARNING: Chained uses of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a></code> do not lead to uniform distributions. Consider the expression <code class="fsharp hljs">xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>&nbsp;xA2&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>&nbsp;xA3</code>.  It parenhesizes as <code class="fsharp hljs">(xA1&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>&nbsp;xA2)&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a>&nbsp;xA3</code>.  This means that <code class="fsharp hljs">xA3</code> has a 50% and both <code class="fsharp hljs">xA1</code> and <code class="fsharp hljs">xA2</code> have 25% probability of being considered first.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;~&gt;*" href="#dec:val%20Hopac.Infixes.&lt;~&gt;*">&lt;~&gt;*</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;~&gt;">&lt;~&gt;</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;=" href="#dec:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that first runs the given job and then passes the result of that job to the given function to build another job which will then be run.  This is the same as <code class="fsharp hljs">bind</code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;=*" href="#dec:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-" href="#dec:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that runs the given job and maps the result of the job with the given function.  <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;x2y</code> is an optimized version of <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;(x2y&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)</code>.  This is the same as <code class="fsharp hljs">map</code> with the arguments flipped.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-*" href="#dec:val%20Hopac.Infixes.&gt;&gt;-*">&gt;&gt;-*</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;=." href="#dec:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that runs the given two jobs and returns the result of the second job.  <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a>&nbsp;yJ</code> is equivalent to <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;yJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;=*." href="#dec:val%20Hopac.Infixes.&gt;&gt;=*.">&gt;&gt;=*.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-." href="#dec:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; 'y -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
<p> Creates a job that runs the given job and then returns the given value. <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>&nbsp;y</code> is an optimized version of <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>&nbsp;y</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-*." href="#dec:val%20Hopac.Infixes.&gt;&gt;-*.">&gt;&gt;-*.</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; 'y -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'y&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-!" href="#dec:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> Creates a job that runs the given job and then raises the given exception. <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a>&nbsp;e</code> is equivalent to <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;fun&nbsp;_&nbsp;-&gt;&nbsp;raise&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;&gt;-*!" href="#dec:val%20Hopac.Infixes.&gt;&gt;-*!">&gt;&gt;-*!</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;_&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;=&gt;" href="#dec:val%20Hopac.Infixes.&gt;=&gt;">&gt;=&gt;</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
</code></pre>
<p> Creates a job that is the composition of the given two job constructors. <code class="fsharp hljs">(x2yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;=&gt;">&gt;=&gt;</a>&nbsp;y2zJ)&nbsp;x</code> is equivalent to <code class="fsharp hljs">x2yJ&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;y2zJ</code> and is much like the <code class="fsharp hljs">&gt;&gt;</code> operator on ordinary functions.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;=&gt;*" href="#dec:val%20Hopac.Infixes.&gt;=&gt;*">&gt;=&gt;*</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;=&gt;">&gt;=&gt;</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;" href="#dec:val%20Hopac.Infixes.&gt;-&gt;">&gt;-&gt;</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; 'z) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
</code></pre>
<p> Creates a job that is the composition of the given job constructor and function.  <code class="fsharp hljs">(x2yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;-&gt;">&gt;-&gt;</a>&nbsp;y2z)&nbsp;x</code> is equivalent to <code class="fsharp hljs">x2yJ&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a>&nbsp;y2z</code> and is much like the <code class="fsharp hljs">&gt;&gt;</code> operator on ordinary functions.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;*" href="#dec:val%20Hopac.Infixes.&gt;-&gt;*">&gt;-&gt;*</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('y -&gt; 'z) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;-&gt;">&gt;-&gt;</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;=&gt;." href="#dec:val%20Hopac.Infixes.&gt;=&gt;.">&gt;=&gt;.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
</code></pre>
<p> <code class="fsharp hljs">(x2yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;=&gt;.">&gt;=&gt;.</a>&nbsp;zJ)&nbsp;x</code> is equivalent to <code class="fsharp hljs">x2yJ&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a>&nbsp;zJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;=&gt;*." href="#dec:val%20Hopac.Infixes.&gt;=&gt;*.">&gt;=&gt;*.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;=&gt;.">&gt;=&gt;.</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;." href="#dec:val%20Hopac.Infixes.&gt;-&gt;.">&gt;-&gt;.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; 'z -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'z&gt;
</code></pre>
<p> <code class="fsharp hljs">(x2yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;-&gt;.">&gt;-&gt;.</a>&nbsp;z)&nbsp;x</code> is equivalent to <code class="fsharp hljs">x2yJ&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a>&nbsp;z</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;*." href="#dec:val%20Hopac.Infixes.&gt;-&gt;*.">&gt;-&gt;*.</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; 'z -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'z&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;-&gt;.">&gt;-&gt;.</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;!" href="#dec:val%20Hopac.Infixes.&gt;-&gt;!">&gt;-&gt;!</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; exn -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;
</code></pre>
<p> <code class="fsharp hljs">(x2yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;-&gt;!">&gt;-&gt;!</a>&nbsp;e)&nbsp;x</code> is equivalent to <code class="fsharp hljs">x2yJ&nbsp;x&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;-!">&gt;&gt;-!</a>&nbsp;e</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&gt;-&gt;*!" href="#dec:val%20Hopac.Infixes.&gt;-&gt;*!">&gt;-&gt;*!</a> ): ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; exn -&gt; 'x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;_&gt;
</code></pre>
<p> A memoizing version of <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;-&gt;!">&gt;-&gt;!</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;&amp;&gt;" href="#dec:val%20Hopac.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;
</code></pre>
<p> Creates a job that runs the given two jobs and then returns a pair of their results.  <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>&nbsp;yJ</code> is equivalent to <code class="fsharp hljs">xJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;fun&nbsp;x&nbsp;-&gt;&nbsp;yJ&nbsp;<a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;fun&nbsp;y&nbsp;-&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>&nbsp;(x,&nbsp;y)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;*&gt;" href="#dec:val%20Hopac.Infixes.&lt;*&gt;">&lt;*&gt;</a> ): <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x * 'y&gt;
</code></pre>
<p> Creates a job that either runs the given jobs sequentially, like <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a></code>, or as two separate parallel jobs and returns a pair of their results.</p>
<p> Note that when the jobs are run in parallel and both of them raise an exception then the created job raises an <code class="fsharp hljs">AggregateException</code>.</p>
<p> Note that, because it is not guaranteed that the jobs would always be run as separate parallel jobs, a job such as</p>
<pre><code class="fsharp hljs">let mayDeadlock = delay &lt;| fun () -&gt;
  let c = <a href="#def:type%20Hopac.Ch">Ch</a> ()
  <a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.give">give</a> c () <a href="#def:val%20Hopac.Infixes.&lt;*&gt;">&lt;*&gt;</a> <a href="#def:module%20Hopac.Ch">Ch</a>.<a href="#def:val%20Hopac.Ch.take">take</a> c
</code></pre>
<p> may deadlock.  If two jobs need to communicate with each other they need to be started as two separate jobs.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val ( <a id="def:val Hopac.Infixes.&lt;+&gt;" href="#dec:val%20Hopac.Infixes.&lt;+&gt;">&lt;+&gt;</a> ): <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x * 'y&gt;
</code></pre>
<p> An alternative that is equivalent to first committing to either one of the given alternatives and then committing to the other alternative.  Note that this is not the same as committing to both of the alternatives in a single transaction.  Such an operation would require a more complex synchronization protocol like with the so called Transactional Events.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Proc" href="#dec:type%20Hopac.Proc">Proc</a> =
</code></pre>
<p> Represents a handle to a (started, running or terminated) job.</p>
<p> A handle makes it possible to determine when a job is known to have been terminated.  An example use for handles would be a system where critical resources are managed by a server job and those critical resources need to be released even in case a client job suffers from a fault and is terminated before properly releasing resources.</p>
<p> For performance reasons, Hopac creates handles lazily for simple jobs, because for many uses of lightweight threads such a capability is simply not necessary.  However, when handles are known to be needed, it is better to allocate them eagerly by directly starting jobs using <code class="fsharp hljs"><a href="#def:module%20Hopac.Proc">Proc</a>.<a href="#def:val%20Hopac.Proc.start">start</a></code> or <code class="fsharp hljs"><a href="#def:module%20Hopac.Proc">Proc</a>.<a href="#def:val%20Hopac.Proc.queue">queue</a></code>.</p>
<div class="description"><pre><code class="fsharp hljs">inherit <a id="def:inherit Hopac.Proc.Alt" href="#dec:inherit%20Hopac.Proc.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:type%20Hopac.Proc">Proc</a></code> is a subtype of <code class="fsharp hljs"><a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;</code> and <code class="fsharp hljs">p&nbsp;:&gt;&nbsp;<a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Proc">Proc</a>.<a href="#def:val%20Hopac.Proc.join">join</a>&nbsp;p</code>.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Proc" href="#dec:module%20Hopac.Proc">Proc</a> =
</code></pre>
<p> Operations on handles.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.queue" href="#dec:val%20Hopac.Proc.queue">queue</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
</code></pre>
<p> Creates a job that queues a new job with a handle.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.start">start</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.queueIgnore" href="#dec:val%20Hopac.Proc.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
</code></pre>
<p> Creates a job that queues a new job with a handle.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Proc.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.start" href="#dec:val%20Hopac.Proc.start">start</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
</code></pre>
<p> Creates a job that starts a new job with a handle.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.queue">queue</a></code>, <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.startIgnore" href="#dec:val%20Hopac.Proc.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
</code></pre>
<p> Creates a job that starts a new job with a handle.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Proc.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.bind" href="#dec:val%20Hopac.Proc.bind">bind</a>: (<a href="#def:type%20Hopac.Proc">Proc</a> -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Creates a job that calls the given job contructor with the handle of the current job.</p>
<p> Note that this is an <code class="fsharp hljs">O(n)</code> operation where <code class="fsharp hljs">n</code> is the number of continuation or stack frames of the current job.  In most cases this should not be an issue, but if you need to repeatedly access the proc handle of the current job it may be advantageous to cache it in a local variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.map" href="#dec:val%20Hopac.Proc.map">map</a>: (<a href="#def:type%20Hopac.Proc">Proc</a> -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.map">map</a>&nbsp;p2x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.bind">bind</a>&nbsp;(p2x&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.self" href="#dec:val%20Hopac.Proc.self">self</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Proc">Proc</a>&gt;
</code></pre>
<p> Returns a job that returns the handle of the current job.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.self">self</a>&nbsp;()</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Proc.bind">bind</a>&nbsp;<a href="#def:val%20Hopac.Job.result">result</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Proc.join" href="#dec:val%20Hopac.Proc.join">join</a>: <a href="#def:type%20Hopac.Proc">Proc</a> -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Returns an alternative that becomes available once the job corresponding to the handle is known to have been terminated for any reason.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.JobBuilder" href="#dec:type%20Hopac.JobBuilder">JobBuilder</a> =
</code></pre>
<p> Expression builder type for jobs.</p>
<p> The following expression constructs are supported:</p>
<pre><code class="fsharp hljs">... ; ...
do ...
do! ... | async | task | obs
for ... = ... to ... do ...
for ... in ... do ...
if ... then ...
if ... then ... else ...
let ... = ... in ...
let! ... = ... | async | task | obs in ...
match ... with ...
return ...
return! ... | async | task
try ... finally ...
try ... with ...
use ... = ... in ...
use! ... = ... in ...
while ... do ...
</code></pre>
<p> In the above, an ellipsis denotes either a job, an ordinary expression or a pattern.  A job workflow can also directly bind and return from async operations, which will be started on a Hopac worker thread (see <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.fromAsync">fromAsync</a></code>), tasks (see <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.awaitTask">awaitTask</a></code>) and observables (see <code class="fsharp hljs"><a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt;.<a href="#def:member%20Hopac.Extensions.IObservable.onceAlt">onceAlt</a></code>).</p>
<p> Note that the <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a></code> module provides more combinators for constructing jobs. For example, the F# workflow notation does not support <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryFinallyJob">tryFinallyJob</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryIn">tryIn</a></code> is easier to use correctly than <code class="fsharp hljs">try&nbsp;...&nbsp;with&nbsp;...</code> expressions.  Operators such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Infixes.&gt;&gt;-.">&gt;&gt;-.</a></code> and operations such as <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.iterate">iterate</a></code> and <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.forever">forever</a></code> are frequently useful and may improve performance.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.JobBuilder.new" href="#dec:new%20Hopac.JobBuilder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.JobBuilder">JobBuilder</a>
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Bind" href="#dec:member%20Hopac.JobBuilder.Bind">Bind</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.1.Bind" href="#dec:member%20Hopac.JobBuilder.1.Bind">Bind</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.2.Bind" href="#dec:member%20Hopac.JobBuilder.2.Bind">Bind</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.3.Bind" href="#dec:member%20Hopac.JobBuilder.3.Bind">Bind</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Combine" href="#dec:member%20Hopac.JobBuilder.Combine">Combine</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; * (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Delay" href="#dec:member%20Hopac.JobBuilder.Delay">Delay</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.For" href="#dec:member%20Hopac.JobBuilder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Return" href="#dec:member%20Hopac.JobBuilder.Return">Return</a>: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.ReturnFrom" href="#dec:member%20Hopac.JobBuilder.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.1.ReturnFrom" href="#dec:member%20Hopac.JobBuilder.1.ReturnFrom">ReturnFrom</a>: <a href="#def:module%20Hopac.Extensions.Async">Async</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.2.ReturnFrom" href="#dec:member%20Hopac.JobBuilder.2.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.3.ReturnFrom" href="#dec:member%20Hopac.JobBuilder.3.ReturnFrom">ReturnFrom</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Run" href="#dec:member%20Hopac.JobBuilder.Run">Run</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.TryFinally" href="#dec:member%20Hopac.JobBuilder.TryFinally">TryFinally</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) * (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.TryWith" href="#dec:member%20Hopac.JobBuilder.TryWith">TryWith</a>: (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) * (exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Using" href="#dec:member%20Hopac.JobBuilder.Using">Using</a>: 'x * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt; when 'x :&gt; IDisposable
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.While" href="#dec:member%20Hopac.JobBuilder.While">While</a>: (unit -&gt; bool) * (unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.JobBuilder.Zero" href="#dec:member%20Hopac.JobBuilder.Zero">Zero</a>: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.EmbeddedJob" href="#dec:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt; = struct
</code></pre>
<p> Represents a job to be embedded within a computation built upon jobs.</p>
<p> Embedded jobs can be useful when defining computations built upon jobs. Having to encode lightweight threads using the job monad is somewhat unfortunate, because it is such a fundamental abstraction.  One sometimes, perhaps even often, wants to define more interesting computations upon jobs, but the traditional way of doing that requires adding yet another costly layer of abstraction on top of jobs.  Another possibility is to expose the <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;</code> type constructor as shown in the following example:</p>
<pre><code class="fsharp hljs">type Monad&lt;'x&gt;
</code></pre>
<pre><code class="fsharp hljs">type MonadBuilder =
  member Delay: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt;
  member Return: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt;
  member Bind:   <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;
  member Bind: <a href="#def:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt;  * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;
</code></pre>
<p> The <code class="fsharp hljs">Monad&lt;'x&gt;</code> type constructor and the <code class="fsharp hljs">MonadBuilder</code> defines the new computation mechanism on top of jobs.  The <code class="fsharp hljs">Bind</code> operation taking an <code class="fsharp hljs"><a href="#def:type%20Hopac.EmbeddedJob">EmbeddedJob</a>&lt;'x&gt;</code> allows one to conveniently embed arbitrary jobs within the computations without introducing nasty overload resolution problems.</p>
<p> Consider what would happen if one would instead define <code class="fsharp hljs">MonadBuilder</code> as follows:</p>
<pre><code class="fsharp hljs">type MonadBuilder =
  member Delay: unit -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt;
  member Return: 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt;
  member Bind: <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'x&gt;&gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;
  member Bind: <a href="#def:type%20Hopac.Job">Job</a>&lt;      'x &gt; * ('x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;Monad&lt;'y&gt;&gt;
</code></pre>
<p> A <code class="fsharp hljs">Bind</code> operation is now almost always ambiguous and one would have to annotate bind expressions to resolve the ambiguity.</p>
<p> The types of the operations in the <code class="fsharp hljs">MonadBuilder</code> may, at first glance, seem complicated.  Essentially the covariant positions in the signature are wrapped with the <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;</code> type constructor to make it possible to use lightweight threads.  In a language with built-in lightweight threads this would be unnecessary.  Reading the signature by mentally replacing every <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;</code> with just <code class="fsharp hljs">'x</code>, the signature should become clear.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.EmbeddedJobBuilder" href="#dec:type%20Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a> =
</code></pre>
<p> A builder for embedded jobs.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Scheduler" href="#dec:type%20Hopac.Scheduler">Scheduler</a>
</code></pre>
<p> Represents a scheduler that manages a number of worker threads.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Scheduler" href="#dec:module%20Hopac.Scheduler">Scheduler</a> =
</code></pre>
<p> Operations on schedulers.  Use of this module requires more intimate knowledge of Hopac, but may allow adapting Hopac to special application requirements.</p>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Scheduler.Create" href="#dec:type%20Hopac.Scheduler.Create">Create</a> =
</code></pre>
<p> A record of scheduler configuration options.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:field Hopac.Scheduler.Create.Foreground" href="#dec:field%20Hopac.Scheduler.Create.Foreground">Foreground</a>: option&lt;bool&gt;
</code></pre>
<p> Specifies whether worker threads are run as background threads or as foreground threads.  The default is to run workers as background threads.  If you want to run worker threads as foreground threads, then you will have to explicitly kill the worker threads.  Using foreground threads is probably preferable if your application dynamically creates and kills local schedulers to make sure the worker threads are properly killed.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:field Hopac.Scheduler.Create.IdleHandler" href="#dec:field%20Hopac.Scheduler.Create.IdleHandler">IdleHandler</a>: option&lt;<a href="#def:type%20Hopac.Job">Job</a>&lt;int&gt;&gt;
</code></pre>
<p> Specifies the idle handler for workers.  The worker idle handler is run whenever an individual worker runs out of work.  The idle handler must return an integer value that specifies how many milliseconds the worker is allowed to sleep.  <code class="fsharp hljs">Timeout.Infinite</code> puts the worker into sleep until the scheduler explicitly wakes it up.  <code class="fsharp hljs">0</code> means that the idle handler found some new work and the worker should immediately look for it.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:field Hopac.Scheduler.Create.MaxStackSize" href="#dec:field%20Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a>: option&lt;int&gt;
</code></pre>
<p> Specifies the maximum stack size for worker threads.  The default is to use the default maximum stack size of the <code class="fsharp hljs">Thread</code> class.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:field Hopac.Scheduler.Create.NumWorkers" href="#dec:field%20Hopac.Scheduler.Create.NumWorkers">NumWorkers</a>: option&lt;int&gt;
</code></pre>
<p> Number of worker threads.  Using more than <code class="fsharp hljs">Environment.ProcessorCount</code> is not optimal and may, in some cases, significantly reduce performance.  The default is <code class="fsharp hljs">Environment.ProcessorCount</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs"><a id="def:field Hopac.Scheduler.Create.TopLevelHandler" href="#dec:field%20Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a>: option&lt;exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;&gt;
</code></pre>
<p> Specifies the top level exception handler job constructor of the scheduler.  When a job fails with an otherwise unhandled exception, the job is killed and a new job is constructed with the top level handler constructor and then started.  To avoid infinite loops, in case the top level handler job raises exceptions, it is simply killed after printing a message to the console.  The default top level handler simply prints out a message to the console.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">static member <a id="def:static member Hopac.Scheduler.Create.Def" href="#dec:static%20member%20Hopac.Scheduler.Create.Def">Def</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a>
</code></pre>
<p> Default options.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Scheduler.Global" href="#dec:module%20Hopac.Scheduler.Global">Global</a> =
</code></pre>
<p> Operations on the global scheduler.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.Global.setCreate" href="#dec:val%20Hopac.Scheduler.Global.setCreate">setCreate</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a> -&gt; unit
</code></pre>
<p> Sets options for creating the global scheduler.  This must be called before invoking any Hopac functionality that implicitly creates the global scheduler.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.create" href="#dec:val%20Hopac.Scheduler.create">create</a>: <a href="#def:type%20Hopac.Scheduler.Create">Create</a> -&gt; <a href="#def:type%20Hopac.Scheduler">Scheduler</a>
</code></pre>
<p> Creates a new local scheduler.</p>
<p> Note that a local scheduler does not automatically implement services such as the global wall-clock timer.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.queue" href="#dec:val%20Hopac.Scheduler.queue">queue</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
</code></pre>
<p> Queues the given job for execution on the scheduler.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code> instead.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.queueIgnore" href="#dec:val%20Hopac.Scheduler.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; unit
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Scheduler.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.server" href="#dec:val%20Hopac.Scheduler.server">server</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; unit
</code></pre>
<p> Like <code class="fsharp hljs"><a href="#def:module%20Hopac.Scheduler">Scheduler</a>.<a href="#def:val%20Hopac.Scheduler.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.start" href="#dec:val%20Hopac.Scheduler.start">start</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
</code></pre>
<p> Starts running the given job, but does not wait for the job to finish.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a></code> instead.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.startIgnore" href="#dec:val%20Hopac.Scheduler.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; unit
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Scheduler.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.startWithActions" href="#dec:val%20Hopac.Scheduler.startWithActions">startWithActions</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; (exn -&gt; unit) -&gt; ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; unit
</code></pre>
<p> Starts running the given job, but does not wait for the job to finish. Upon the failure or success of the job, one of the given actions is called once.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Job.abort">abort</a></code>.</p>
<p> Note that using this function in a job workflow is not optimal and you should instead use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a></code> with desired Job exception handling construct (e.g. <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryIn">tryIn</a></code> or <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.catch">catch</a></code>).</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.run" href="#dec:val%20Hopac.Scheduler.run">run</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; 'x
</code></pre>
<p> Starts running the given job on the specified scheduler and then blocks the current thread waiting for the job to either return successfully or fail.</p>
<p> WARNING: Use of <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.run">run</a></code> should be considered carefully, because calling <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.run">run</a></code> from an arbitrary thread can cause deadlock.</p>
<p> A call of <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.run">run</a>&nbsp;xJ</code> is safe when the call is not made from within a Hopac worker thread and the job <code class="fsharp hljs">xJ</code> does not perform operations that might block or that might directly, or indirectly, need to communicate with the thread from which <code class="fsharp hljs"><a href="#def:val%20Hopac.Scheduler.run">run</a></code> is being called.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.wait" href="#dec:val%20Hopac.Scheduler.wait">wait</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; unit
</code></pre>
<p> Waits until the scheduler becomes completely idle.</p>
<p> Note that for this to make sense, the scheduler should be a local scheduler that your program manages explicitly.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Scheduler.kill" href="#dec:val%20Hopac.Scheduler.kill">kill</a>: <a href="#def:type%20Hopac.Scheduler">Scheduler</a> -&gt; unit
</code></pre>
<p> Kills the worker threads of the scheduler one-by-one.  This should only be used with a local scheduler that is known to be idle.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Stream" href="#dec:module%20Hopac.Stream">Stream</a> =
</code></pre>
<p> Operations on choice streams.</p>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.Cons" href="#dec:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt; =
</code></pre>
<p> Represents a point in a non-deterministic stream of values.</p>
<div class="description"><pre><code class="fsharp hljs">| <a id="def:| Hopac.Stream.Cons.Cons" href="#dec:|%20Hopac.Stream.Cons.Cons">Cons</a> of <a href="#def:member%20Hopac.Stream.Property.Value">Value</a>: 'x * Next: <a href="#def:type%20Hopac.Promise">Promise</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;
</code></pre>
<p> Communicates a value and the remainder of the stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">| <a id="def:| Hopac.Stream.Cons.Nil" href="#dec:|%20Hopac.Stream.Cons.Nil">Nil</a>
</code></pre>
<p> Communicates the end of the stream.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.Stream" href="#dec:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; = <a href="#def:type%20Hopac.Promise">Promise</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;
</code></pre>
<p> Represents a non-deterministic stream of values called a choice stream.</p>
<p> Choice streams are essentially lazy lists of promises.  Anything that can be done using ordinary lazy lists can also be done using choice streams. In addition, choice streams allow asynchronicity at any point and have a concept of time making it possible to support various operations, such as a non-deterministic <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.merge">merge</a></code>, that are not supported by ordinary lazy lists.</p>
<p> Thanks to the additional power compared to ordinary lazy lists, choice streams can be used to solve similar problems as Rx observable sequences. However, the underlying implementations of choice streams and observable sequences are almost polar opposites: choice streams are pull based immutable (or write once) chains, while observable sequences are push based imperative pipes.  Many things that are difficult with observables can be easy with choice streams and vice versa.</p>
<p> Probably the most notable advantage of observable sequences over choice streams is that observables support disposables via their all-or-nothing subscription protocol.  Choice streams cannot support disposables in the exact same manner, because elements are requested asynchronously one at a time and choice streams do not have a subscription protocol.  However, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.onCloseJob">onCloseJob</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.doFinalizeJob">doFinalizeJob</a></code> provide similar functionality.</p>
<p> On the other hand, choice streams offer several advantages over observable sequences:</p>
<p> - Choice streams are simple and allow consumers and producers to be written using simple programming techniques such as lexical binding, recursion and immutable data structures.  You can see many examples of this in the reference implementations of various stream combinators. Observable sequences can only be subscribed to by imperative callbacks. The implementation of choice streams is two orders of magnitude shorter than the implementation of .Net Rx.</p>
<p> - Basically all operations on ordinary lazy streams can be implemented on and are meaningful on choice streams.  The same is not true of observable sequences, because they do not compose the same way.  Many trivial choice stream combinators, such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tails">tails</a></code>, can be either impossible or very challenging to specify and implement meaningfully for observable sequences.</p>
<p> - Choice streams allow for the use of asynchronous programming at any point.  Most higher-order choice stream combinators have both an asynchronous <code class="fsharp hljs"><a href="#def:type%20Hopac.Job">Job</a></code> and a synchronous <code class="fsharp hljs">Fun</code> form.  For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.iterJob">iterJob</a></code> waits for the asynchronous job to finish before consuming the next value from the stream.  The <code class="fsharp hljs">Subscribe</code> operation of observables cannot support such behavior, because <code class="fsharp hljs">OnNext</code> calls are synchronous.</p>
<p> - Choice streams are consistent in that every consumer of a stream gets the exact same sequence of values unlike with observable sequences.  In other words, choice streams are immutable and elements are not discarded implicitly.  There is no need for <code class="fsharp hljs">Connect</code> and <code class="fsharp hljs">Publish</code> or <code class="fsharp hljs">Replay</code> like with observable sequences.</p>
<p> - The asynchronous one element at a time model of choice streams allows for a basic form of backpressure or the flow of synchronization from consumers to producers.  This allows for many new operations to be expressed.  For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a></code> cannot be implemented for observable sequences.  Operations such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.afterEach">afterEach</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.beforeEach">beforeEach</a></code> have semantics that are pull based and lazy and cannot be implemented for observable sequences.  Operations such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a></code>, or <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a></code> in disguise, have new uses.</p>
<p> All of the above advantages are strongly related and result from the pull based nature of choice streams.  Pull semantics puts the consumer in control.</p>
<p> While the most common operations are very easy to implement on choice streams, some operations perhaps require more intricate programming than with push based models.  For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.groupByFun">groupByFun</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code>, which corresponds to <code class="fsharp hljs">Delay</code> in Rx, are non-trivial, although both implementations are actually much shorter than their .Net Rx counterparts.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.Src" href="#dec:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt;
</code></pre>
<p> Represents an imperative source of a stream of values called a stream source.</p>
<p> A basic use for a stream source would be to produce a stream in response to events from a GUI.  For example, given a GUI button, one could write</p>
<pre><code class="fsharp hljs">let buttonClickSrc = <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:module%20Hopac.Stream.Src">Src</a>.<a href="#def:val%20Hopac.Stream.Src.create">create</a> ()
button.Click.Add (ignore &gt;&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:module%20Hopac.Stream.Src">Src</a>.<a href="#def:val%20Hopac.Stream.Src.value">value</a> buttonClickSrc &gt;&gt; start)
</code></pre>
<p> to produce a stream of button clicks.  The <code class="fsharp hljs"><a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:module%20Hopac.Stream.Src">Src</a>.<a href="#def:val%20Hopac.Stream.Src.tap">tap</a></code> function returns the generated stream, which can then be manipulated using stream combinators.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ofObservableOnMain">ofObservableOnMain</a></code>.</p>
<p> Here is a silly example.  We could write a stream combinator that counts the number of events within a given timeout period:</p>
<pre><code class="fsharp hljs">let eventsWithin timeout xs =
  let inc = xs |&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.mapConst">mapConst</a> +1
  let dec = xs |&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.mapConst">mapConst</a> -1 |&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.shift">shift</a> timeout
  <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.merge">merge</a> inc dec
  |&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.scanFromFun">scanFromFun</a> 0 (+)
</code></pre>
<p> Given two stream sources for buttons, the following program would then print "That was fast!" whenever both buttons are clicked within 500ms.</p>
<pre><code class="fsharp hljs">let t500ms = timeOutMillis 500
let n1s = <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:module%20Hopac.Stream.Src">Src</a>.<a href="#def:val%20Hopac.Stream.Src.tap">tap</a> button1ClickSrc |&gt; eventsWithin t500ms
let n2s = <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:module%20Hopac.Stream.Src">Src</a>.<a href="#def:val%20Hopac.Stream.Src.tap">tap</a> button2ClickSrc |&gt; eventsWithin t500ms
<a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.combineLatest">combineLatest</a> n1s n2s
|&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.chooseFun">chooseFun</a> (fun (n1, n2) -&gt;
   if n1 &gt; 0 &amp;&amp; n2 &gt; 0 then Some () else None)
|&gt; <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:val%20Hopac.Stream.consumeFun">consumeFun</a> (fun () -&gt; printfn "That was fast!")
</code></pre>
<p> Note that there are no special hidden mechanisms involved in the implementation of stream sources.  You can easily implement similar imperative mechanisms outside of the stream library.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Stream.Src" href="#dec:module%20Hopac.Stream.Src">Src</a> =
</code></pre>
<p> Operations on stream sources.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Src.create" href="#dec:val%20Hopac.Stream.Src.create">create</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt;
</code></pre>
<p> Creates a new stream source.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Src.value" href="#dec:val%20Hopac.Stream.Src.value">value</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Appends a new value to the end of the generated stream.  This operation is atomic and non-blocking and can be safely used from multiple parallel jobs.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Src.error" href="#dec:val%20Hopac.Stream.Src.error">error</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; exn -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Terminates the stream with an error.  The given exception is raised in the consumers of the stream if and when they reach the end of the stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Src.close" href="#dec:val%20Hopac.Stream.Src.close">close</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Terminates the stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Src.tap" href="#dec:val%20Hopac.Stream.Src.tap">tap</a>: <a href="#def:type%20Hopac.Stream.Src">Src</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the remainder of the generated stream after the point in time when <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.Src.tap">tap</a></code> is called.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.Var" href="#dec:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt;
</code></pre>
<p> Represents a mutable variable, called a stream variable, that generates a stream of values as a side-effect.  See also: <code class="fsharp hljs">MVar&lt;'x&gt;</code>.</p>
<p> The difference between a stream variable and a stream source is that a stream variable cannot be closed and always has a value.  Stream variables are one way to represent state, or the model, manipulated by a program using streams.</p>
<p> Note that there are no special hidden mechanisms involved in the implementation of stream variables.  You can easily implement similar imperative mechanisms outside of the stream library.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Stream.Var" href="#dec:module%20Hopac.Stream.Var">Var</a> =
</code></pre>
<p> Operations on stream variables.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Var.create" href="#dec:val%20Hopac.Stream.Var.create">create</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt;
</code></pre>
<p> Creates a new stream variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Var.get" href="#dec:val%20Hopac.Stream.Var.get">get</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; 'x
</code></pre>
<p> Gets the value of the variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Var.set" href="#dec:val%20Hopac.Stream.Var.set">set</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Sets the value of the variable and appends the value to the end of the generated stream.  Note that while this operation is atomic, and can be safely used from multiple parallel jobs, a combination of <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.Var.get">get</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.Var.set">set</a></code> is not atomic.  See also: <code class="fsharp hljs">MVar&lt;'x&gt;</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.Var.tap" href="#dec:val%20Hopac.Stream.Var.tap">tap</a>: <a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the generated stream, including the current value of the variable, from the point in time when <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.Var.tap">tap</a></code> is called.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.MVar" href="#dec:type%20Hopac.Stream.MVar">MVar</a>&lt;'x&gt;
</code></pre>
<p> Represents a serialized mutable stream variable that generates a stream of values as a side-effect.  The difference between <code class="fsharp hljs">MVar&lt;'x&gt;</code> and <code class="fsharp hljs"><a href="#def:type%20Hopac.Stream.Var">Var</a>&lt;'x&gt;</code> is that read-modify-write operations, such as <code class="fsharp hljs">MVar.<a href="#def:val%20Hopac.Stream.MVar.updateJob">updateJob</a></code>, are serialized, so they effectively appear as atomic, like with the ordinary <code class="fsharp hljs">MVar&lt;'x&gt;</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">module <a id="def:module Hopac.Stream.MVar" href="#dec:module%20Hopac.Stream.MVar">MVar</a> =
</code></pre>
<p> Operations on serialized stream variables.</p>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.create" href="#dec:val%20Hopac.Stream.MVar.create">create</a>: 'x -&gt; MVar&lt;'x&gt;
</code></pre>
<p> Creates a new serialized stream variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.get" href="#dec:val%20Hopac.Stream.MVar.get">get</a>: MVar&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Returns a job that gets the value of the variable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.set" href="#dec:val%20Hopac.Stream.MVar.set">set</a>: MVar&lt;'x&gt; -&gt; 'x -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that sets the value of the variable.  Note that a combination of <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.get">get</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.set">set</a></code> is not serialized.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.updateFun">updateFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.updateFun" href="#dec:val%20Hopac.Stream.MVar.updateFun">updateFun</a>: MVar&lt;'x&gt; -&gt; ('x -&gt; 'x) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that updates the value of the variable with the given function in a serialized fashion.  If the function raises an exception, the variable will not be modified.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.updateJob">updateJob</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.updateJob" href="#dec:val%20Hopac.Stream.MVar.updateJob">updateJob</a>: MVar&lt;'x&gt; -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Creates a job that updates the value of the variable with the given job in a serialized fashion.  If the job raises an exception, the variable will not be modified.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.updateFun">updateFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.MVar.tap" href="#dec:val%20Hopac.Stream.MVar.tap">tap</a>: MVar&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the generated stream, including the current value of the variable, from the point in time when <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.MVar.tap">tap</a></code> is called.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Stream.Property" href="#dec:type%20Hopac.Stream.Property">Property</a>&lt;'x&gt; =
</code></pre>
<p> Represents a mutable property, much like a stream variable, that generates a stream of values and property change notifications as a side-effect.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Stream.Property.new" href="#dec:new%20Hopac.Stream.Property.new">new</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Property">Property</a>&lt;'x&gt;
</code></pre>
<p> Creates a new property with the specified initial value.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Property.Value" href="#dec:member%20Hopac.Stream.Property.Value">Value</a>: 'x with get, set
</code></pre>
<p> Allows to get and set the value of a <code class="fsharp hljs"><a href="#def:type%20Hopac.Stream.Property">Property</a>&lt;'x&gt;</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Property.Tap" href="#dec:member%20Hopac.Stream.Property.Tap">Tap</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the generated stream, including the current value of the property, from the point in time when <code class="fsharp hljs"><a href="#def:member%20Hopac.Stream.Property.Tap">Tap</a></code> is called.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.nil" href="#dec:val%20Hopac.Stream.nil">nil</a>&lt;'x&gt; : <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> An empty or closed choice stream.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code> is also the identity element for the <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.merge">merge</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a></code> combinators.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code> is equivalent to <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a>&nbsp;<a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.never" href="#dec:val%20Hopac.Stream.never">never</a>&lt;'x&gt; : <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> A choice stream that never produces any values and never closes.  While perhaps rarely used, this is theoretically important as the identity element for the <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switch">switch</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.amb">amb</a></code> combinators.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.cons" href="#dec:val%20Hopac.Stream.cons">cons</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;x&nbsp;xs</code> constructs a choice stream whose first value is <code class="fsharp hljs">x</code> and the rest of the stream is computed using <code class="fsharp hljs">xs</code>.  For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;1&nbsp;&lt;&lt;&nbsp;<a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;2&nbsp;&lt;&lt;&nbsp;<a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;3&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;4&nbsp;<a href="#def:val%20Hopac.Stream.nil">nil</a></code> is a stream producing the sequence <code class="fsharp hljs">1&nbsp;2&nbsp;3&nbsp;4</code>. See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;x&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a>&nbsp;(<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&nbsp;(x,&nbsp;xs))</code>.</p>
<p> Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code> directly correspond to the ordinary list constructors <code class="fsharp hljs">::</code> and <code class="fsharp hljs">[]</code> and, aside from the obvious notational differences, you can construct choice streams just like you would create ordinary lists.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.delay" href="#dec:val%20Hopac.Stream.delay">delay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'x&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a></code> creates a stream that is constructed lazily.  Use <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a></code> to make lazy streams and to avoid unbounded eager recursion.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a>&nbsp;u2xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:type%20Hopac.Promise">Promise</a>&nbsp;(<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a>&nbsp;u2xs)</code>.</p>
<p> Note that with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code>, you can express arbitrary lazy streams.  For example,</p>
<pre><code class="fsharp hljs">let fibs: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;BigInteger&gt; =
  let rec lp f0 f1 = <a href="#def:val%20Hopac.Stream.cons">cons</a> f0 &lt;&lt; <a href="#def:val%20Hopac.Stream.delay">delay</a> &lt;| fun () -&gt; lp f1 (f0 + f1)
  lp 0I 1I
</code></pre>
<p> is the stream of all fibonacci numbers.</p>
<p> The above <code class="fsharp hljs">fibs</code> streams produces results lazily, but can do so at a relatively fast rate when it is being pulled eagerly.  The following</p>
<pre><code class="fsharp hljs">let slowFibs =
  fibs
  |&gt; <a href="#def:val%20Hopac.Stream.afterEach">afterEach</a> (timeOutMillis 1000)
</code></pre>
<p> stream would produce the fibonacci sequence with at most one element per second.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.error" href="#dec:val%20Hopac.Stream.error">error</a>: exn -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Constructs a choice stream that is closed with an error.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.one" href="#dec:val%20Hopac.Stream.one">one</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream of length one containing the given value.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.one">one</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;x&nbsp;<a href="#def:val%20Hopac.Stream.nil">nil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.repeat" href="#dec:val%20Hopac.Stream.repeat">repeat</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Creates an infinite stream of the given value.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.repeat">repeat</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cycle">cycle</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.one">one</a>&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ofSeq" href="#dec:val%20Hopac.Stream.ofSeq">ofSeq</a>: seq&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Converts the given sequence to a lazy stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.once" href="#dec:val%20Hopac.Stream.once">once</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a lazy stream that, when pulled, runs the given job, produces the result of the job and closes.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.once">once</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.take">take</a>&nbsp;1</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.indefinitely" href="#dec:val%20Hopac.Stream.indefinitely">indefinitely</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a lazy stream whose elements are generated by running the given job.  For example, given a channel, <code class="fsharp hljs">xCh</code>, a stream can be created, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a>&nbsp;xCh</code>, through which all the values given on the channel can be observed.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.values">values</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a> xJ = xJ <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> fun x -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> x &lt;| <a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a> xJ
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.unfoldJob" href="#dec:val%20Hopac.Stream.unfoldJob">unfoldJob</a>: ('s -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'x * 's&gt;&gt;) -&gt; ('s -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;)
</code></pre>
<p> Returns a lazy stream that contains the elements generated by the given job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code>.</p>
<p> For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJob">mapJob</a></code> could be defined via <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a></code> as follows:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Stream.mapJob">mapJob</a> x2yJ xs =
  xs
  |&gt; <a href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a> (fun xs -&gt;
     xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; <a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.result">result</a> None
                   | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt;
                     x2yJ x <a href="#def:val%20Hopac.Infixes.&gt;&gt;-">&gt;&gt;-</a> fun y -&gt; Some (y, xs))
</code></pre>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a> f =
  f <a href="#def:val%20Hopac.Infixes.&gt;=&gt;*">&gt;=&gt;*</a> function None -&gt; <a href="#def:val%20Hopac.Stream.nil">nil</a>
                | Some (x, s) -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> x &lt;| <a href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a> f s
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.unfoldFun" href="#dec:val%20Hopac.Stream.unfoldFun">unfoldFun</a>: ('s -&gt; option&lt;'x * 's&gt;) -&gt; ('s -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;)
</code></pre>
<p> Returns a lazy stream that contains the elements generated by the given function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">[&lt;AbstractClass&gt;] 
type <a id="def:type Hopac.Stream.GenerateFuns" href="#dec:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt; =
</code></pre>
<p> Generator functions for <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.generateFuns">generateFuns</a></code>.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Stream.GenerateFuns.new" href="#dec:new%20Hopac.Stream.GenerateFuns.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt;
</code></pre>
<p> Default constructor.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.GenerateFuns.While" href="#dec:abstract%20Hopac.Stream.GenerateFuns.While">While</a>: 's -&gt; bool
</code></pre>
<p> Called to determine whether to generate more.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.GenerateFuns.Next" href="#dec:abstract%20Hopac.Stream.GenerateFuns.Next">Next</a>: 's -&gt; 's
</code></pre>
<p> Called to compute next state.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.GenerateFuns.Select" href="#dec:abstract%20Hopac.Stream.GenerateFuns.Select">Select</a>: 's -&gt; 'x
</code></pre>
<p> Called to extract value from state.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.generateFuns" href="#dec:val%20Hopac.Stream.generateFuns">generateFuns</a>: 's -&gt; <a href="#def:type%20Hopac.Stream.GenerateFuns">GenerateFuns</a>&lt;'s, 'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Generates a stream from the given state using the given function object.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.generateFun" href="#dec:val%20Hopac.Stream.generateFun">generateFun</a>: initial: 's
              -&gt; doWhile: ('s -&gt; bool)
              -&gt; doNext: ('s -&gt; 's)
              -&gt; doSelect: ('s -&gt; 'x)
              -&gt; Stream&lt;'x&gt;
</code></pre>
<p> Generates a stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.iterateJob" href="#dec:val%20Hopac.Stream.iterateJob">iterateJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns an infinite stream of repeated applications of the given job to the given initial value.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.iterateJob">iterateJob</a> f x = f x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> <a href="#def:val%20Hopac.Stream.iterateJob">iterateJob</a> f |&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> x
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.iterateFun" href="#dec:val%20Hopac.Stream.iterateFun">iterateFun</a>: ('x -&gt; 'x) -&gt; 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns an infinite stream of repeated applications of the given function to the given initial value.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.afterDateTimeOffsets" href="#dec:val%20Hopac.Stream.afterDateTimeOffsets">afterDateTimeOffsets</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt;
</code></pre>
<p> Given a stream of dates, returns a stream that produces the dates after the dates.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.afterDateTimeOffset" href="#dec:val%20Hopac.Stream.afterDateTimeOffset">afterDateTimeOffset</a>: DateTimeOffset -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;DateTimeOffset&gt;
</code></pre>
<p> Returns a stream that produces the given date after the given date.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.afterTimeSpan" href="#dec:val%20Hopac.Stream.afterTimeSpan">afterTimeSpan</a>: TimeSpan -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;unit&gt;
</code></pre>
<p> Returns a stream that produces an element after the given time span.  Note that streams are memoized.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.shift" href="#dec:val%20Hopac.Stream.shift">shift</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces the same sequence of elements as the given stream, but shifted in time by the given timeout.</p>
<pre><code class="fsharp hljs">  input: 1        2 3   4        5
timeout: +---x    +---x +---x
                    +---x        +---x
 output:     1        2 3   4        5
</code></pre>
<p> The <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code> operation pulls the input while the stream returned by <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code> is being pulled.  If the stream produced by <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code> is not pulled, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code> will stop pulling the input.  This basically means that the timing of the output can be determined by an eager producer of the input.</p>
<p> Note that this operation has a fairly complex implementation.  Unless you absolutely want this behavior, you might prefer a combinator such as <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delayEach">delayEach</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.combineLatest" href="#dec:val%20Hopac.Stream.combineLatest">combineLatest</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x * 'y&gt;
</code></pre>
<p> Returns a stream that produces a new pair of elements whenever either one of the given pair of streams produces an element.  If one of the streams produces multiple elements before any elements are produced by the other stream, then those elements are skipped.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a></code>.</p>
<pre><code class="fsharp hljs"> xs: 1 2                  3     4
 ys:     a     b     c
xys:   (2,a) (2,b) (2,c)(3,c) (4,c)
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.debounce" href="#dec:val%20Hopac.Stream.debounce">debounce</a>: timeout: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.debounce">debounce</a>&nbsp;timeout&nbsp;elements</code> returns a stream so that after each element a timeout is started and the element is produced if no other elements is received before the timeout is signaled.  Note that if the given stream produces elements more frequently than the timeout, the returned stream never produces any elements.</p>
<pre><code class="fsharp hljs">elements: 1        2 3  4     5 6 7 8 9 ...
 timeout: +---x    +-+--+---x +-+-+-+-+-...
  output:     1             4
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ignoreUntil" href="#dec:val%20Hopac.Stream.ignoreUntil">ignoreUntil</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ignoreUntil">ignoreUntil</a>&nbsp;timeout&nbsp;elements</code> returns a stream that, after getting an element, starts a timeout and produces the last element received when the timeout is signaled.</p>
<pre><code class="fsharp hljs">elements: 1   2      3       4 5 6
<a href="#def:header%20Hopac.Hopac.timeouts">timeouts</a>: +-----x    +-----x +-----x
  output:       2          3       6
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ignoreWhile" href="#dec:val%20Hopac.Stream.ignoreWhile">ignoreWhile</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ignoreWhile">ignoreWhile</a>&nbsp;timeout&nbsp;elements</code> returns a stream that, after getting an element, starts a timeout, produces the element and ignores other elements until the timeout is signaled.</p>
<pre><code class="fsharp hljs">elements: 1   2      3       4 5 6
<a href="#def:header%20Hopac.Hopac.timeouts">timeouts</a>: +-----x    +-----x +-----x
  output: 1          3       4
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.samplesBefore" href="#dec:val%20Hopac.Stream.samplesBefore">samplesBefore</a>: ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.samplesBefore">samplesBefore</a>&nbsp;ticks&nbsp;elements</code> returns a stream that consumes both ticks and elements and produces each element that precedes a tick.  Excess elements from both streams are skipped.</p>
<pre><code class="fsharp hljs">elements: 1  2  3        4 5 6  7
   ticks:     x    x    x     x   x
  output:     2    3          6   7
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.samplesAfter" href="#dec:val%20Hopac.Stream.samplesAfter">samplesAfter</a>: ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.samplesAfter">samplesAfter</a>&nbsp;ticks&nbsp;elements</code> returns a stream that consumes both ticks and elements and produces each element that follows a tick.  Excess elements from both streams are skipped.</p>
<pre><code class="fsharp hljs">elements: 1  2  3        4 5 6  7
   ticks:     x    x    x     x   x
  output:       3        4      7
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.skipUntil" href="#dec:val%20Hopac.Stream.skipUntil">skipUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that discards elements from the given stream until the given alternative is committed to after which the remainder of the given stream is produced.  Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.takeUntil">takeUntil</a>&nbsp;evt&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.skipUntil">skipUntil</a>&nbsp;evt&nbsp;xs</code> may not be equivalent to <code class="fsharp hljs">xs</code>, because there is an inherent race-condition.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.takeAndSkipUntil">takeAndSkipUntil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.takeUntil" href="#dec:val%20Hopac.Stream.takeUntil">takeUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces elements from the given stream until the given alternative is committed to after which the returned stream is closed.  Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.takeUntil">takeUntil</a>&nbsp;evt&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.skipUntil">skipUntil</a>&nbsp;evt&nbsp;xs</code> may not be equivalent to <code class="fsharp hljs">xs</code>, because there is an inherent race-condition. See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.takeAndSkipUntil">takeAndSkipUntil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.takeAndSkipUntil" href="#dec:val%20Hopac.Stream.takeAndSkipUntil">takeAndSkipUntil</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a pair of streams of which the first one takes elements from the given stream and the second skips elements from the given stream until the given alternative is committed to.  It is guaranteed that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.takeAndSkipUntil">takeAndSkipUntil</a>&nbsp;evt&nbsp;xs&nbsp;|&gt;&nbsp;fun&nbsp;(hs,&nbsp;ts)&nbsp;-&gt;&nbsp;<a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;hs&nbsp;ts</code> is equivalent to <code class="fsharp hljs">xs</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.skipUntil">skipUntil</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.takeUntil">takeUntil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">[&lt;AbstractClass&gt;] 
type <a id="def:type Hopac.Stream.KeepPrecedingFuns" href="#dec:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt; =
</code></pre>
<p> Functions for collecting elements from a live stream to be lazified.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Stream.KeepPrecedingFuns.new" href="#dec:new%20Hopac.Stream.KeepPrecedingFuns.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt;
</code></pre>
<p> Default constructor.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.KeepPrecedingFuns.First" href="#dec:abstract%20Hopac.Stream.KeepPrecedingFuns.First">First</a>: 'x -&gt; 'y
</code></pre>
<p> Called to begin the next batch of elements.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.KeepPrecedingFuns.Next" href="#dec:abstract%20Hopac.Stream.KeepPrecedingFuns.Next">Next</a>: 'y * 'x -&gt; 'y
</code></pre>
<p> Called to add an element to the current batch.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.keepPrecedingFuns" href="#dec:val%20Hopac.Stream.keepPrecedingFuns">keepPrecedingFuns</a>: <a href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;'x, 'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Converts a given imperative live stream into a lazy stream by spawning a job to eagerly consume and collect elements from the live stream using the given <code class="fsharp hljs"><a href="#def:type%20Hopac.Stream.KeepPrecedingFuns">KeepPrecedingFuns</a>&lt;_,&nbsp;_&gt;</code> object.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.keepPreceding" href="#dec:val%20Hopac.Stream.keepPreceding">keepPreceding</a>: maxCount: int -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;Queue&lt;'x&gt;&gt;
</code></pre>
<p> Converts a given imperative live stream into a lazy stream of queued elements by spawning a job to eagerly consume and queue elements from the live stream.  At most <code class="fsharp hljs">maxCount</code> most recent elements are kept in a queue and after that the oldest elements are thrown away.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.keepPreceding1" href="#dec:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Converts an imperative live stream into a lazy stream by spawning a job to eagerly consume (and throw away) elements from the live stream and to produce only one most recent element each time when requested.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepPreceding">keepPreceding</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a></code>.</p>
<p> Basically,</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a> |&gt; <a href="#def:val%20Hopac.Stream.afterEach">afterEach</a> timeout
</code></pre>
<p> is similar to</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.ignoreWhile">ignoreWhile</a> timeout
</code></pre>
<p> and</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a> |&gt; <a href="#def:val%20Hopac.Stream.beforeEach">beforeEach</a> timeout
</code></pre>
<p> is similar to</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.ignoreUntil">ignoreUntil</a> timeout
</code></pre>
<p> However, a lazified stream, assuming there is enough CPU time to consume elements from the live stream, never internally holds to an arbitrary number of stream conses.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.keepFollowing1" href="#dec:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Converts an imperative live stream into a lazy stream by spawning a job to eagerly consume (and throw away) elements from the live stream and to produce only one element after each pull request.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.afterEach" href="#dec:val%20Hopac.Stream.afterEach">afterEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces the same elements as the given stream, but after each element, the given job is used as a delay before a request is made to the given stream for the next element.  If the given job fails, the returned stream also fails.</p>
<p> Suppose that an application needs to poll for some information, e.g. by making a http request, using a job named <code class="fsharp hljs">poll</code>.  Using <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a></code> and <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.afterEach">afterEach</a></code> we can specify a stream for polling:</p>
<pre><code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a> poll
|&gt; <a href="#def:val%20Hopac.Stream.afterEach">afterEach</a> (timeOutMillis 10000)
</code></pre>
<p> The above stream ensures that polls are at least 10 seconds apart.  Also when polls are requested less frequently, there is no delay before a poll.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.beforeEach" href="#dec:val%20Hopac.Stream.beforeEach">beforeEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that runs the given job each time a value is requested before requesting the next value from the given stream.  If the given job fails, the returned stream also fails.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.beforeEach">beforeEach</a>&nbsp;yJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a>&nbsp;(<a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a>&nbsp;yJ)&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.delayEach" href="#dec:val%20Hopac.Stream.delayEach">delayEach</a>: timeout: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces the same elements as the given stream, but delays each pulled element using the given job.  If the given job fails, the returned stream also fails.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delayEach">delayEach</a>&nbsp;yJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zipWithFun">zipWithFun</a>&nbsp;(fun&nbsp;x&nbsp;_&nbsp;-&gt;&nbsp;x)&nbsp;xs&nbsp;(<a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a>&nbsp;yJ)</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code>.</p>
<pre><code class="fsharp hljs">  input: 1        2 3   4        5
timeout: +---x    +---x---x---x  +---x
 output:     1        2   3   4      5
</code></pre>
<p> In the above, the <code class="fsharp hljs">input</code> is considered to be independent of the pull operations performed by <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delayEach">delayEach</a></code>.  For streams that produce output infrequently in relation to the timeout, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delayEach">delayEach</a></code> behaves similarly to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.shift">shift</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.pullOn" href="#dec:val%20Hopac.Stream.pullOn">pullOn</a>: ticks: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;_&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Given a stream of ticks and a lazy stream of elements returns a stream of elements pulled from the lazy stream based on the ticks.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a></code>.</p>
<p> For example,</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.keepPreceding1">keepPreceding1</a> |&gt; <a href="#def:val%20Hopac.Stream.pullOn">pullOn</a> ticks
</code></pre>
<p> is similar to</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.samplesBefore">samplesBefore</a> ticks
</code></pre>
<p> and</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.keepFollowing1">keepFollowing1</a> |&gt; <a href="#def:val%20Hopac.Stream.pullOn">pullOn</a> ticks
</code></pre>
<p> is similar to</p>
<pre><code class="fsharp hljs">live |&gt; <a href="#def:val%20Hopac.Stream.samplesAfter">samplesAfter</a> ticks
</code></pre>
<p> However, a lazified stream, assuming there is enough CPU time to consume elements from the live stream, never internally holds to an arbitrary number of stream conses.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a>&nbsp;ts&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zipWithFun">zipWithFun</a>&nbsp;(fun&nbsp;_&nbsp;x&nbsp;-&gt;&nbsp;x)&nbsp;ts&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.zip" href="#dec:val%20Hopac.Stream.zip">zip</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x * 'y&gt;
</code></pre>
<p> Returns a stream of pairs of elements from the given pair of streams.  No elements from either stream are skipped and each element is used only once.  In <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a>&nbsp;xs&nbsp;ys</code>, the <code class="fsharp hljs">xs</code> stream is examined first.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.pullOn">pullOn</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.combineLatest">combineLatest</a></code>.</p>
<p> For example,</p>
<pre><code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a> xs &lt;| <a href="#def:val%20Hopac.Stream.tail">tail</a> xs
</code></pre>
<p> is a stream of consecutive pairs from the stream <code class="fsharp hljs">xs</code>.</p>
<p> Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a></code> consumes the same number of elements from both given streams.  If one of the streams accumulates elements faster than the other stream, there will be an effective space leak.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.zipWithFun" href="#dec:val%20Hopac.Stream.zipWithFun">zipWithFun</a>: ('x -&gt; 'y -&gt; 'z) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zipWithFun">zipWithFun</a>&nbsp;f&nbsp;xs&nbsp;ys</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.zip">zip</a>&nbsp;xs&nbsp;ys&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;(fun&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;f&nbsp;x&nbsp;y)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ofObservableOn" href="#dec:val%20Hopac.Stream.ofObservableOn">ofObservableOn</a>: subscribeOn: SynchronizationContext -&gt; <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Subscribes to the given observable on the specified synchronization context and returns the events pushed by the observable as a stream.  A finalizer is used to automatically unsubscribe from the observable after the stream is no longer reachable.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ofObservableOnMain" href="#dec:val%20Hopac.Stream.ofObservableOnMain">ofObservableOnMain</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ofObservableOnMain">ofObservableOnMain</a>&nbsp;xO</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ofObservable">ofObservable</a>&nbsp;main&nbsp;xO</code>, where <code class="fsharp hljs">main</code> is the main synchronization context as set by application code using <code class="fsharp hljs"><a href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ofObservable" href="#dec:val%20Hopac.Stream.ofObservable">ofObservable</a>: <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ofObservable">ofObservable</a>&nbsp;xO</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ofObservableOn">ofObservableOn</a>&nbsp;null&nbsp;xO</code>.  Note that it is often necessary to specify the synchronization context to subscribe on. See also: <code class="fsharp hljs">Observable.SubscribeOn</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.toObservable" href="#dec:val%20Hopac.Stream.toObservable">toObservable</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.IObservable">IObservable</a>&lt;'x&gt;
</code></pre>
<p> Returns an observable that eagerly consumes the given stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapJob" href="#dec:val%20Hopac.Stream.mapJob">mapJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Returns a stream that produces elements passed through the given job whenever the given streams produces elements.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.mapJob">mapJob</a> f xs =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; <a href="#def:val%20Hopac.Stream.nil">nil</a>
                 | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt;
                   f x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> fun y -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> y &lt;| <a href="#def:val%20Hopac.Stream.mapJob">mapJob</a> f xs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapFun" href="#dec:val%20Hopac.Stream.mapFun">mapFun</a>: ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Returns a stream that produces elements passed through the given function whenever the given streams produces elements.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;x2y</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJob">mapJob</a>&nbsp;(<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.lift">lift</a>&nbsp;x2y)</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapPipelinedJob" href="#dec:val%20Hopac.Stream.mapPipelinedJob">mapPipelinedJob</a>: degree: int -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapPipelinedJob">mapPipelinedJob</a>&nbsp;degree&nbsp;x2yJ&nbsp;xs</code> is like <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs</code> except that up to <code class="fsharp hljs">degree</code> number of jobs constructed with <code class="fsharp hljs">x2yJ</code> may be run in parallel.</p>
<p> Note that due to the sequential nature of streams, this simply isn't an effective solution for fine grained parallel processing.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapPipelinedFun" href="#dec:val%20Hopac.Stream.mapPipelinedFun">mapPipelinedFun</a>: degree: int -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapPipelinedFun">mapPipelinedFun</a>&nbsp;degree&nbsp;x2y&nbsp;xs</code> is like <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;x2y&nbsp;xs</code> except that up to <code class="fsharp hljs">degree</code> number of invocations of <code class="fsharp hljs">x2y</code> may be run in parallel.</p>
<p> Note that due to the sequential nature of streams, this simply isn't an effective solution for fine grained parallel processing.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapConst" href="#dec:val%20Hopac.Stream.mapConst">mapConst</a>: 'y -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Returns a stream that produces the given element each time the given stream produces an element.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapIgnore" href="#dec:val%20Hopac.Stream.mapIgnore">mapIgnore</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.mapIgnore">mapIgnore</a></code> is equivalent to <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.mapConst">mapConst</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.chooseJob" href="#dec:val%20Hopac.Stream.chooseJob">chooseJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Returns a stream that produces results whenever the given stream produces an element and the given job returns <code class="fsharp hljs">Some</code> result from that element.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.chooseJob">chooseJob</a> f xs =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; <a href="#def:val%20Hopac.Stream.nil">nil</a>
                 | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt;
                   f x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function None -&gt; <a href="#def:val%20Hopac.Stream.chooseJob">chooseJob</a> f xs
                                   | Some y -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> y &lt;| <a href="#def:val%20Hopac.Stream.chooseJob">chooseJob</a> f xs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.chooseFun" href="#dec:val%20Hopac.Stream.chooseFun">chooseFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Returns a stream that produces results whenever the given stream produces an element and the given function returns <code class="fsharp hljs">Some</code> result from that element.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.choose" href="#dec:val%20Hopac.Stream.choose">choose</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;option&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.choose">choose</a></code> is equivalent to <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.chooseFun">chooseFun</a>&nbsp;id</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.filterJob" href="#dec:val%20Hopac.Stream.filterJob">filterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that contains the elements from the given stream for which the given job returns <code class="fsharp hljs">true</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.filterFun" href="#dec:val%20Hopac.Stream.filterFun">filterFun</a>: ('x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that contains the elements from the given stream for which the given function returns <code class="fsharp hljs">true</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.groupByJob" href="#dec:val%20Hopac.Stream.groupByJob">groupByJob</a>: ('k -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'y&gt;) -&gt; ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; when 'k: equality
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.groupByJob">groupByJob</a>&nbsp;newGroup&nbsp;keyOf&nbsp;elems</code> splits the given source stream into substreams or groups based on the keys extracted from the elements by <code class="fsharp hljs">keyOf</code> and formed using <code class="fsharp hljs">newGroup</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.groupByFun">groupByFun</a></code>.</p>
<p> New groups are formed by calling the given function with a key, a job for closing the substream and the substream.  Unless explicitly closed, substreams remain alive as long as the source stream.  When closing substreams, it is important to understand that streams operate concurrently.  This means that one should always consume the substream until it ends after closing it.  If, after closing a substream, the given stream produces more elements with the same key, a new substream with the key will be opened.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.groupByFun" href="#dec:val%20Hopac.Stream.groupByFun">groupByFun</a>: ('k -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'y) -&gt; ('x -&gt; 'k) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; when 'k: equality
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.groupByJob">groupByJob</a>&nbsp;newGroup&nbsp;keyOf&nbsp;elems</code> splits the given source stream into substreams or groups based on the keys extracted from the elements by <code class="fsharp hljs">keyOf</code> and formed using <code class="fsharp hljs">newGroup</code>.  See <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.groupByJob">groupByJob</a></code> for further details.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.buffer" href="#dec:val%20Hopac.Stream.buffer">buffer</a>: int -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;array&lt;'x&gt;&gt;
</code></pre>
<p> Converts a stream of elements into a stream of non-overlapping buffers of at most given number of elements.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.scanJob" href="#dec:val%20Hopac.Stream.scanJob">scanJob</a>: ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
</code></pre>
<p> Returns a stream whose elements are computed using the given job and initial state as with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldJob">foldJob</a></code>.</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.scanJob">scanJob</a> f s xs =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; <a href="#def:val%20Hopac.Stream.nil">nil</a>
                 | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt;
                   f s x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> fun s -&gt; <a href="#def:val%20Hopac.Stream.scanJob">scanJob</a> f s xs
  |&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> s
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.scanFun" href="#dec:val%20Hopac.Stream.scanFun">scanFun</a>: ('s -&gt; 'x -&gt; 's) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
</code></pre>
<p> Returns a stream whose elements are computed using the given function and initial state as with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFun">foldFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.scanFromJob" href="#dec:val%20Hopac.Stream.scanFromJob">scanFromJob</a>: 's -&gt; ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.scanFromJob">scanFromJob</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.scanJob">scanJob</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.scanFromFun" href="#dec:val%20Hopac.Stream.scanFromFun">scanFromFun</a>: 's -&gt; ('s -&gt; 'x -&gt; 's) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'s&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.scanFromFun">scanFromFun</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.scanFun">scanFun</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctByJob" href="#dec:val%20Hopac.Stream.distinctByJob">distinctByJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
</code></pre>
<p> Returns a stream that contains no duplicate entries based on the keys returned by the given job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctByFun" href="#dec:val%20Hopac.Stream.distinctByFun">distinctByFun</a>: ('x -&gt; 'k) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
</code></pre>
<p> Returns a stream that contains no duplicate entries based on the keys returned by the given function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctUntilChangedWithJob" href="#dec:val%20Hopac.Stream.distinctUntilChangedWithJob">distinctUntilChangedWithJob</a>: ('x -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that contains no successive duplicate elements according to the given comparison job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctUntilChangedWithFun" href="#dec:val%20Hopac.Stream.distinctUntilChangedWithFun">distinctUntilChangedWithFun</a>: ('x -&gt; 'x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that contains no successive duplicate elements according to the given comparison function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctUntilChangedByJob" href="#dec:val%20Hopac.Stream.distinctUntilChangedByJob">distinctUntilChangedByJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'k&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
</code></pre>
<p> Returns a stream that contains no successive duplicate elements based on the keys returned by the given job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctUntilChangedByFun" href="#dec:val%20Hopac.Stream.distinctUntilChangedByFun">distinctUntilChangedByFun</a>: ('x -&gt; 'k) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'k: equality
</code></pre>
<p> Returns a stream that contains no successive duplicate elements based on the keys returned by the given function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.distinctUntilChanged" href="#dec:val%20Hopac.Stream.distinctUntilChanged">distinctUntilChanged</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; when 'x: equality
</code></pre>
<p> Returns a stream that contains no successive duplicate elements.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Stream.distinctUntilChanged">distinctUntilChanged</a> xs =
  <a href="#def:val%20Hopac.Stream.append">append</a> (<a href="#def:val%20Hopac.Stream.head">head</a> xs)
   (<a href="#def:val%20Hopac.Stream.zip">zip</a> xs (<a href="#def:val%20Hopac.Stream.tail">tail</a> xs)
    |&gt; <a href="#def:val%20Hopac.Stream.chooseFun">chooseFun</a> (fun (x0, x1) -&gt;
       if x0 &lt;&gt; x1 then Some x1 else None))
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.skip" href="#dec:val%20Hopac.Stream.skip">skip</a>: int64 -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.skip">skip</a>&nbsp;n&nbsp;xs</code> returns a stream without the first <code class="fsharp hljs">n</code> elements of the given stream.  If the given stream is shorter than <code class="fsharp hljs">n</code>, then the returned stream will be empty.  Note that if <code class="fsharp hljs">n</code> is non-negative, then <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.take">take</a>&nbsp;n&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.skip">skip</a>&nbsp;n&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.take" href="#dec:val%20Hopac.Stream.take">take</a>: int64 -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.take">take</a>&nbsp;n</code> returns a stream that has the first <code class="fsharp hljs">n</code> elements of the given stream.  If the given stream is shorter than <code class="fsharp hljs">n</code>, then <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.take">take</a>&nbsp;n</code> is the identity function.  Note that if <code class="fsharp hljs">n</code> is non-negative, then <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.take">take</a>&nbsp;n&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.skip">skip</a>&nbsp;n&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.skipWhileJob" href="#dec:val%20Hopac.Stream.skipWhileJob">skipWhileJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the stream without the maximal prefix of elements that satisfy the given predicate given as a job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.skipWhileFun" href="#dec:val%20Hopac.Stream.skipWhileFun">skipWhileFun</a>: ('x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the stream without the maximal prefix of elements that satisfy the given predicate given as a function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.takeWhileJob" href="#dec:val%20Hopac.Stream.takeWhileJob">takeWhileJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;bool&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the maximal prefix of the given stream of elements that satisfy the given predicate given as a job.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.takeWhileFun" href="#dec:val%20Hopac.Stream.takeWhileFun">takeWhileFun</a>: ('x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns the maximal prefix of the given stream of elements that satisfy the given predicate given as a function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.catch" href="#dec:val%20Hopac.Stream.catch">catch</a>: (exn -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces the same sequence of elements as the given stream.  If the given stream fails, a new stream is constructed by calling the given function and that stream becomes the remainder of the stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.onCloseJob" href="#dec:val%20Hopac.Stream.onCloseJob">onCloseJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that is just like the given stream except that just before the returned stream is closed, due to the given stream being closed, whether with an error or without, the given job is executed.  In case the job raises an exception, that exception closes the returned stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.onCloseFun">onCloseFun</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.doFinalizeJob">doFinalizeJob</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.onCloseFun" href="#dec:val%20Hopac.Stream.onCloseFun">onCloseFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that is just like the given stream except that just before the returned stream is closed, due to the given stream being closed, whether with an error or without, the given function is called. In case the function raises an exception, that exception closes the returned stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.onCloseJob">onCloseJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.doFinalizeFun">doFinalizeFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.doFinalizeJob" href="#dec:val%20Hopac.Stream.doFinalizeJob">doFinalizeJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that is just like the given stream except that after the returned stream is closed or becomes garbage, the given job is started as a separate concurrent job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.doFinalizeFun">doFinalizeFun</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.onCloseJob">onCloseJob</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.doFinalizeFun" href="#dec:val%20Hopac.Stream.doFinalizeFun">doFinalizeFun</a>: (unit -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that is just like the given stream except that after the returned stream is closed or becomes garbage, a separate job is started that calls the given function.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.doFinalizeJob">doFinalizeJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.onCloseFun">onCloseFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.count" href="#dec:val%20Hopac.Stream.count">count</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;int64&gt;
</code></pre>
<p> Returns a job that computes the length of the given stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldJob" href="#dec:val%20Hopac.Stream.foldJob">foldJob</a>: ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> Eagerly reduces the given stream using the given job.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldFun" href="#dec:val%20Hopac.Stream.foldFun">foldFun</a>: ('s -&gt; 'x -&gt; 's) -&gt; 's -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> Eagerly reduces the given stream using the given function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldFromJob" href="#dec:val%20Hopac.Stream.foldFromJob">foldFromJob</a>: 's -&gt; ('s -&gt; 'x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromJob">foldFromJob</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldJob">foldJob</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldFromFun" href="#dec:val%20Hopac.Stream.foldFromFun">foldFromFun</a>: 's -&gt; ('s -&gt; 'x -&gt; 's) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromFun">foldFromFun</a>&nbsp;s&nbsp;sx2s&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFun">foldFun</a>&nbsp;sx2s&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldBack" href="#dec:val%20Hopac.Stream.foldBack">foldBack</a>: ('x -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; -&gt; 'sJ) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'sJ -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; when 'sJ :&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> Performs a lazy backwards fold over the stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldJob">foldJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.unfoldJob">unfoldJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a></code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code> is a fundamental function on streams.  Consider that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a>&nbsp;<a href="#def:val%20Hopac.Stream.cons">cons</a>&nbsp;xs&nbsp;<a href="#def:val%20Hopac.Stream.nil">nil</a></code> is equivalent to <code class="fsharp hljs">xs</code>.  Many other stream functions can be implemented using <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code>.  For example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJob">mapJob</a></code> could be defined using <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code> as follows:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Stream.mapJob">mapJob</a> x2yJ xs =
  <a href="#def:val%20Hopac.Stream.foldBack">foldBack</a> (fun x s -&gt; x2yJ x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> fun y -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> y s) xs <a href="#def:val%20Hopac.Stream.nil">nil</a>
</code></pre>
<p> Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a></code> allows the same to written more concisely.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.foldBack">foldBack</a> x2s2sJ xs s =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; s
                 | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt; x2s2sJ x &lt;| <a href="#def:val%20Hopac.Stream.foldBack">foldBack</a> x2s2sJ xs s
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.foldFromBack" href="#dec:val%20Hopac.Stream.foldFromBack">foldFromBack</a>: 'sJ -&gt; (<a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; -&gt; 'x -&gt; 'sJ) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'s&gt; when 'sJ :&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'s&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a>&nbsp;s&nbsp;s2x2sJ&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a>&nbsp;(flip&nbsp;s2x2sJ)&nbsp;xs&nbsp;s</code> and is often syntactically more convenient to use.</p>
<p> For example, here is how one could write <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJob">mapJob</a></code> using <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a></code>:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Stream.mapJob">mapJob</a> x2yJ =
  <a href="#def:val%20Hopac.Stream.foldFromBack">foldFromBack</a> <a href="#def:val%20Hopac.Stream.nil">nil</a> &lt;| fun s -&gt; x2yJ <a href="#def:val%20Hopac.Infixes.&gt;=&gt;*">&gt;=&gt;*</a> flip <a href="#def:val%20Hopac.Stream.cons">cons</a> s
</code></pre>
<p> Contrast the above to how the same can be written using <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.foldBack">foldBack</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.tryPickJob" href="#dec:val%20Hopac.Stream.tryPickJob">tryPickJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tryPickJob">tryPickJob</a>&nbsp;x2yOJ&nbsp;xs</code> returns a job that returns the first <code class="fsharp hljs">Some&nbsp;y</code> result produced by the job <code class="fsharp hljs">x2yOJ&nbsp;x</code> for an element <code class="fsharp hljs">x</code> of the <code class="fsharp hljs">xs</code> stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.tryPickFun" href="#dec:val%20Hopac.Stream.tryPickFun">tryPickFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;option&lt;'y&gt;&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tryPickFun">tryPickFun</a>&nbsp;x2yO&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tryPickJob">tryPickJob</a>&nbsp;(x2yO&nbsp;&gt;&gt;&nbsp;<a href="#def:val%20Hopac.Job.result">result</a>)&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.iterJob" href="#dec:val%20Hopac.Stream.iterJob">iterJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that iterates the given job constructor over the given stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.consumeJob">consumeJob</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.iterJob">iterJob</a> x2uJ xs =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; Job.unit ()
                | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (x, xs) -&gt; x2uJ x <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a> <a href="#def:val%20Hopac.Stream.iterJob">iterJob</a> x2uJ xs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.iterFun" href="#dec:val%20Hopac.Stream.iterFun">iterFun</a>: ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that iterates the given function over the given stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.iterJob">iterJob</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.consumeFun">consumeFun</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.iter" href="#dec:val%20Hopac.Stream.iter">iter</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;
</code></pre>
<p> Returns a job that iterates over all the elements of the given stream. <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.iter">iter</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.iterFun">iterFun</a>&nbsp;ignore&nbsp;xs</code>.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.consume">consume</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.consumeJob" href="#dec:val%20Hopac.Stream.consumeJob">consumeJob</a>: ('x -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
</code></pre>
<p> <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.consumeJob">consumeJob</a>&nbsp;x2uJ</code> is equivalent to <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.iterJob">iterJob</a>&nbsp;x2uJ&nbsp;|&gt;&nbsp;queue</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.consumeFun" href="#dec:val%20Hopac.Stream.consumeFun">consumeFun</a>: ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
</code></pre>
<p> <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.consumeFun">consumeFun</a>&nbsp;x2u</code> is equivalent to <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.iterFun">iterFun</a>&nbsp;x2u&nbsp;|&gt;&nbsp;queue</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.consume" href="#dec:val%20Hopac.Stream.consume">consume</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; unit
</code></pre>
<p> <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.consume">consume</a></code> is equivalent to <code class="fsharp hljs">xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.iter">iter</a>&nbsp;|&gt;&nbsp;queue</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.head" href="#dec:val%20Hopac.Stream.head">head</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream containing only the first element of the given stream. If the given stream is closed, the result stream will also be closed. Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.head">head</a>&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.tail">tail</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.tail" href="#dec:val%20Hopac.Stream.tail">tail</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream just like the given stream except without the first element.  If the given stream is closed, the result stream will also be closed.  Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.head">head</a>&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.tail">tail</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.init" href="#dec:val%20Hopac.Stream.init">init</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream with all the elements of the given stream except the last element.  If the stream is closed, a closed stream is returned.  Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.init">init</a>&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.last">last</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.last" href="#dec:val%20Hopac.Stream.last">last</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream containing the last element of the given stream.  If the given stream is closed, a closed stream is returned.  Note that <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a>&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.init">init</a>&nbsp;xs&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.last">last</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.inits" href="#dec:val%20Hopac.Stream.inits">inits</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt;
</code></pre>
<p> Returns a stream of all initial segments of the given stream from shortest to longest.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.tails" href="#dec:val%20Hopac.Stream.tails">tails</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt;
</code></pre>
<p> Returns a stream of all final segments of the given stream from longest to shortest.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.tails">tails</a> xs =
  xs <a href="#def:val%20Hopac.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; <a href="#def:val%20Hopac.Stream.nil">nil</a>
                 | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (_, xs) -&gt; <a href="#def:val%20Hopac.Stream.tails">tails</a> xs
  |&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> xs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.initsMapFun" href="#dec:val%20Hopac.Stream.initsMapFun">initsMapFun</a>: (<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.initsMapFun">initsMapFun</a>&nbsp;xs2y&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.inits">inits</a>&nbsp;xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;xs2y</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.tailsMapFun" href="#dec:val%20Hopac.Stream.tailsMapFun">tailsMapFun</a>: (<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tailsMapFun">tailsMapFun</a>&nbsp;xs2y&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.tails">tails</a>&nbsp;xs&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;xs2y</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.append" href="#dec:val%20Hopac.Stream.append">append</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Concatenates the given two streams.  In other words, returns a stream that first produces all the elements from first stream and then all the elements from the second stream.  If the first stream is infinite, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a></code> should not be used, because no elements would be produced from the second stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.appendMap">appendMap</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.appendAll" href="#dec:val%20Hopac.Stream.appendAll">appendAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.appendMap" href="#dec:val%20Hopac.Stream.appendMap">appendMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Maps and joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a></code>.  This is roughly the same function as <code class="fsharp hljs">Seq.collect</code>, but is probably less frequently used with choice streams.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.amb" href="#dec:val%20Hopac.Stream.amb">amb</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Of the two given streams, returns the stream that first produces an element or is closed.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.ambMap">ambMap</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.never">never</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let <a href="#def:val%20Hopac.Stream.amb">amb</a> ls rs = ls <a href="#def:val%20Hopac.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> rs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.merge" href="#dec:val%20Hopac.Stream.merge">merge</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces elements from both of the given streams so that elements from the streams are interleaved non-deterministically in the returned stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mergeMap">mergeMap</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.nil">nil</a></code>.</p>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec mergeSwap ls rs =
  ls <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; rs
                | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (l, ls) -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> l &lt;| <a href="#def:val%20Hopac.Stream.merge">merge</a> rs ls
and <a href="#def:val%20Hopac.Stream.merge">merge</a> ls rs = mergeSwap ls rs <a href="#def:val%20Hopac.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> mergeSwap rs ls
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.switch" href="#dec:val%20Hopac.Stream.switch">switch</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Returns a stream that produces elements from the first stream as long as the second stream produces no elements.  As soon as the second stream produces an element, the returned stream only produces elements from the second stream.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switchTo">switchTo</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switchMap">switchMap</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.never">never</a></code>.</p>
<pre><code class="fsharp hljs"> first: a b    c   d
second:      1  2 3  4 ...
output: a b  1  2 3  4 ...
</code></pre>
<p> Reference implementation:</p>
<pre><code class="fsharp hljs">let rec <a href="#def:val%20Hopac.Stream.switch">switch</a> ls rs =
       rs
  <a href="#def:val%20Hopac.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> ls <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> function <a href="#def:|%20Hopac.Stream.Cons.Nil">Nil</a> -&gt; rs
                     | <a href="#def:type%20Hopac.Stream.Cons">Cons</a> (l, ls) -&gt; <a href="#def:val%20Hopac.Stream.cons">cons</a> l &lt;| <a href="#def:val%20Hopac.Stream.switch">switch</a> ls rs
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.switchTo" href="#dec:val%20Hopac.Stream.switchTo">switchTo</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switchTo">switchTo</a>&nbsp;lhs&nbsp;rhs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switch">switch</a>&nbsp;rhs&nbsp;lhs</code>.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switchTo">switchTo</a></code> is designed to be used in pipelines:</p>
<pre><code class="fsharp hljs">firstStream
|&gt; <a href="#def:val%20Hopac.Stream.switchTo">switchTo</a> otherStream
</code></pre>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ambAll" href="#dec:val%20Hopac.Stream.ambAll">ambAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.amb">amb</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mergeAll" href="#dec:val%20Hopac.Stream.mergeAll">mergeAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.merge">merge</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.switchAll" href="#dec:val%20Hopac.Stream.switchAll">switchAll</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;#<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switch">switch</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ambMap" href="#dec:val%20Hopac.Stream.ambMap">ambMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Maps and joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.amb">amb</a></code>.  This corresponds to the idea of starting several alternative streams in parallel and then only using the one that produces the first result.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mergeMap" href="#dec:val%20Hopac.Stream.mergeMap">mergeMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Maps and joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.merge">merge</a></code>.  This corresponds to interleaving results based on all sources of information.  While this is a theoretically important combinator, <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mergeMap">mergeMap</a></code> is probably not the most useful binding form on choice streams.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.switchMap" href="#dec:val%20Hopac.Stream.switchMap">switchMap</a>: ('x -&gt; #<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> Maps and joins all the streams together with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switch">switch</a></code>.  This is perhaps the most useful binding form with choice streams as this correspond to the idea of producing results based only on the latest source of information.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">[&lt;AbstractClass&gt;] 
type <a id="def:type Hopac.Stream.Builder" href="#dec:type%20Hopac.Stream.Builder">Builder</a> =
</code></pre>
<p> A generic builder for streams.  The abstract <code class="fsharp hljs">Combine</code> and <code class="fsharp hljs">Zero</code> operations need to be implemented in a derived class.  The operations are then used to implement <code class="fsharp hljs">Bind</code>, <code class="fsharp hljs">For</code> and <code class="fsharp hljs">While</code> to get a builder with consistent semantics.</p>
<div class="description"><pre><code class="fsharp hljs"><a id="def:new Hopac.Stream.Builder.new" href="#dec:new%20Hopac.Stream.Builder.new">new</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
</code></pre>
<p> Default constructor.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.Builder.Combine" href="#dec:abstract%20Hopac.Stream.Builder.Combine">Combine</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Called to combine two streams.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">abstract <a id="def:abstract Hopac.Stream.Builder.Zero" href="#dec:abstract%20Hopac.Stream.Builder.Zero">Zero</a>: unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Called to obtain the zero or unit stream corresponding to the <code class="fsharp hljs"><a href="#def:abstract%20Hopac.Stream.Builder.Combine">Combine</a></code> method.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.Bind" href="#dec:member%20Hopac.Stream.Builder.Bind">Bind</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">this.Bind&nbsp;(xs,&nbsp;x2ys)</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJoin">mapJoin</a>&nbsp;(fun&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;this.Combine&nbsp;(x,&nbsp;y))&nbsp;x2ys&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.Delay" href="#dec:member%20Hopac.Stream.Builder.Delay">Delay</a>: (unit -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">this.Delay&nbsp;u2xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a>&nbsp;u2xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.For" href="#dec:member%20Hopac.Stream.Builder.For">For</a>: seq&lt;'x&gt; * ('x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt;
</code></pre>
<p> <code class="fsharp hljs">this.For&nbsp;(xs,&nbsp;x2ys)</code> is equivalent to <code class="fsharp hljs">this.Bind&nbsp;(<a href="#def:val%20Hopac.Stream.ofSeq">ofSeq</a>&nbsp;xs,&nbsp;x2ys)</code></p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.TryWith" href="#dec:member%20Hopac.Stream.Builder.TryWith">TryWith</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; * (exn -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">this.TryWith&nbsp;(xs,&nbsp;e2xs)</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.catch">catch</a>&nbsp;e2xs&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.While" href="#dec:member%20Hopac.Stream.Builder.While">While</a>: (unit -&gt; bool) * <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">this.While&nbsp;(u2b,&nbsp;xs)</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.delay">delay</a>&nbsp;&lt;|&nbsp;fun&nbsp;()&nbsp;-&gt;&nbsp;if&nbsp;u2b&nbsp;()&nbsp;then&nbsp;this.Combine&nbsp;(xs,&nbsp;this.While&nbsp;(u2b,&nbsp;xs))&nbsp;else&nbsp;this.Zero&nbsp;()</code></p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.Yield" href="#dec:member%20Hopac.Stream.Builder.Yield">Yield</a>: 'x -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">this.<a href="#def:member%20Hopac.Stream.Builder.Yield">Yield</a>&nbsp;x</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.one">one</a>&nbsp;x</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">member <a id="def:member Hopac.Stream.Builder.YieldFrom" href="#dec:member%20Hopac.Stream.Builder.YieldFrom">YieldFrom</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> <code class="fsharp hljs">this.<a href="#def:member%20Hopac.Stream.Builder.YieldFrom">YieldFrom</a>&nbsp;xs</code> is equivalent to <code class="fsharp hljs">xs</code>.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.ambed" href="#dec:val%20Hopac.Stream.ambed">ambed</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
</code></pre>
<p> This builder joins substreams with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.amb">amb</a></code> to produce a stream with the first results.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.appended" href="#dec:val%20Hopac.Stream.appended">appended</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
</code></pre>
<p> This builder joins substreams with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.append">append</a></code> to produce a stream with all results in sequential order.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.merged" href="#dec:val%20Hopac.Stream.merged">merged</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
</code></pre>
<p> This builder joins substreams with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.merge">merge</a></code> to produce a stream with all results in completion order.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.switched" href="#dec:val%20Hopac.Stream.switched">switched</a>: <a href="#def:type%20Hopac.Stream.Builder">Builder</a>
</code></pre>
<p> This builder joins substreams with <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.switch">switch</a></code> to produce a stream with the latest results.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.cycle" href="#dec:val%20Hopac.Stream.cycle">cycle</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Creates an infinite repetition of the given stream.  For infinite streams <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.cycle">cycle</a></code> is the identity function.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.values" href="#dec:val%20Hopac.Stream.values">values</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Creates an alternative through which all the values of the stream generated after the point at which the alternative has been created can be read.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.indefinitely">indefinitely</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.joinWith" href="#dec:val%20Hopac.Stream.joinWith">joinWith</a>: ('y -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'z&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'y&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
</code></pre>
<p> Joins all the streams in the given stream of streams together with the given binary join combinator.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.mapJoin" href="#dec:val%20Hopac.Stream.mapJoin">mapJoin</a>: ('y -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt; -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Stream.Cons">Cons</a>&lt;'z&gt;&gt;) -&gt; ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'z&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.mapJoin">mapJoin</a>&nbsp;j&nbsp;f&nbsp;xs</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Stream.joinWith">joinWith</a>&nbsp;j&nbsp;&lt;|&nbsp;<a href="#def:val%20Hopac.Stream.mapFun">mapFun</a>&nbsp;f&nbsp;xs</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Stream.toSeq" href="#dec:val%20Hopac.Stream.toSeq">toSeq</a>: <a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;ResizeArray&lt;'x&gt;&gt;
</code></pre>
<p> Returns a job that collects all the elements from the stream.  This function is provided for testing purposes.</p>
</div>
</div>
<div class="description"><pre><code class="fsharp hljs">[&lt;AutoOpen&gt;]
module <a id="def:module Hopac.Hopac" href="#dec:module%20Hopac.Hopac">Hopac</a> =
</code></pre>
<p> Convenience bindings for programming with Hopac.</p>
<div class="description"><pre><code class="fsharp hljs">type <a id="def:type Hopac.Hopac.Stream" href="#dec:type%20Hopac.Hopac.Stream">Stream</a>&lt;'x&gt; = <a href="#def:module%20Hopac.Stream">Stream</a>.<a href="#def:type%20Hopac.Stream.Stream">Stream</a>&lt;'x&gt;
</code></pre>
<p> Represents a non-deterministic stream of values called a choice stream.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.job" href="#dec:val%20Hopac.Hopac.job">job</a>: <a href="#def:type%20Hopac.JobBuilder">JobBuilder</a>
</code></pre>
<p> Default expression builder for jobs.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.onMain" href="#dec:val%20Hopac.Hopac.onMain">onMain</a>: <a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:type%20Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</code></pre>
<p> Builder for running an async workflow on the main synchronization context and interoperating with Hopac.  The application must call <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:val%20Hopac.Extensions.Async.setMain">setMain</a></code> to configure Hopac with the main synchronization context.</p>
<p> The builder has been constructed by calling <code class="fsharp hljs"><a href="#def:module%20Hopac.Hopac">Hopac</a>.<a href="#def:module%20Hopac.Extensions">Extensions</a>.<a href="#def:module%20Hopac.Extensions.Async">Async</a>.<a href="#def:module%20Hopac.Extensions.Async.Global">Global</a>.<a href="#def:val%20Hopac.Extensions.Async.Global.onMain">onMain</a>&nbsp;()</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.queue" href="#dec:val%20Hopac.Hopac.queue">queue</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
</code></pre>
<p> Queues the given job for execution.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.start">start</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.server">server</a></code>.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.queue">queue</a></code> instead.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.queueIgnore" href="#dec:val%20Hopac.Hopac.queueIgnore">queueIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; unit
</code></pre>
<p> Queues the given job for execution.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Hopac.queue">queue</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.queueDelay" href="#dec:val%20Hopac.Hopac.queueDelay">queueDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; unit
</code></pre>
<p> Queues the given delayed job for execution.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.queueDelay">queueDelay</a>&nbsp;u2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.queueIgnore">queueIgnore</a>&nbsp;&lt;|&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a>&nbsp;u2xJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.server" href="#dec:val%20Hopac.Hopac.server">server</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;<a href="#def:type%20Hopac.Void">Void</a>&gt; -&gt; unit
</code></pre>
<p> Starts running the given job like <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.server">server</a></code> instead.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.start" href="#dec:val%20Hopac.Hopac.start">start</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;unit&gt; -&gt; unit
</code></pre>
<p> Starts running the given job, but does not wait for the job to finish. See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.queue">queue</a></code>, <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.server">server</a></code>.</p>
<p> Note that using this function in a job workflow is not optimal and you should use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a></code> instead.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.startIgnore" href="#dec:val%20Hopac.Hopac.startIgnore">startIgnore</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt; -&gt; unit
</code></pre>
<p> Starts running the given job, but does not wait for the job to finish. <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;|&gt;&nbsp;<a href="#def:val%20Hopac.Hopac.start">start</a></code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.startDelay" href="#dec:val%20Hopac.Hopac.startDelay">startDelay</a>: (unit -&gt; #<a href="#def:type%20Hopac.Job">Job</a>&lt;_&gt;) -&gt; unit
</code></pre>
<p> Starts running the given delayed job, but does not wait for the job to finish.  <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.startDelay">startDelay</a>&nbsp;u2xJ</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.startIgnore">startIgnore</a>&nbsp;&lt;|&nbsp;<a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.delay">delay</a>&nbsp;u2xJ</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.run" href="#dec:val%20Hopac.Hopac.run">run</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; 'x
</code></pre>
<p> Starts running the given job and then blocks the current thread waiting for the job to either return successfully or fail.  See also: <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.start">start</a></code>.</p>
<p> WARNING: Use of <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a></code> should be considered carefully, because calling <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a></code> from an arbitrary thread can cause deadlock.</p>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a></code> is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications.  In Windows applications, for example, <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a></code> should not be called from the GUI thread.</p>
<p> A call of <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a>&nbsp;xJ</code> is safe when the call is not made from within a Hopac worker thread and the job <code class="fsharp hljs">xJ</code> does not perform operations that might block or that might directly, or indirectly, need to communicate with the thread from which <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.run">run</a></code> is being called.</p>
<p> Note that using this function from within a job workflow should never be needed, because within a workflow the result of a job can be obtained by binding.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.queueAsTask" href="#dec:val%20Hopac.Hopac.queueAsTask">queueAsTask</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;
</code></pre>
<p> Queues the given job for execution.  The result can be obtained from the returned task.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.startAsTask" href="#dec:val%20Hopac.Hopac.startAsTask">startAsTask</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Extensions.Task">Task</a>&lt;'x&gt;
</code></pre>
<p> Starts running the given job.  The result can be obtained from the returned task.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.startWithActions" href="#dec:val%20Hopac.Hopac.startWithActions">startWithActions</a>: (exn -&gt; unit) -&gt; ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; unit
</code></pre>
<p> Starts running the given job, but does not wait for the job to finish. Upon the failure or success of the job, one of the given actions is called once.</p>
<p> Note that using this function in a job workflow is not optimal and you should instead use <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.start">start</a></code> with the desired exception handling construct (e.g. <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.tryIn">tryIn</a></code> or <code class="fsharp hljs"><a href="#def:module%20Hopac.Job">Job</a>.<a href="#def:val%20Hopac.Job.catch">catch</a></code>).</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.timeOut" href="#dec:val%20Hopac.Hopac.timeOut">timeOut</a>: TimeSpan -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> Creates an alternative that, after instantiation, becomes available after the specified time span.</p>
<p> Note that the timer mechanism is simply not intended for high precision timing and the resolution of the underlying mechanism is very coarse (Windows system ticks).</p>
<p> Also note that you do not need to create a new timeout alternative every time you need a timeout with a specific time span.  For example, you can create a timeout for one second</p>
<pre><code class="fsharp hljs">let after1s = <a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a> &lt;| TimeSpan.FromSeconds 1.0
</code></pre>
<p> and then use that timeout many times</p>
<pre><code class="fsharp hljs">    makeRequest <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> fun rp -&gt; ...
<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> after1s     <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> fun () -&gt; ...
</code></pre>
<p> Timeouts, like other alternatives, can also directly be used as job level operations.  For example, using the above definition of <code class="fsharp hljs">after1s</code></p>
<pre><code class="fsharp hljs">after1s <a href="#def:val%20Hopac.Infixes.&gt;&gt;=">&gt;&gt;=</a> fun () -&gt; ...
</code></pre>
<p> has the effect of sleeping for one second.</p>
<p> It is an idiomatic approach with Hopac to rely on garbage collection to clean up concurrent jobs than can no longer make progress.  It is therefore important to note that a server loop</p>
<pre><code class="fsharp hljs">let rec serverLoop ... =
      ...
  <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> <a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a> ... <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> ... serverLoop ...
  <a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> ...
</code></pre>
<p> that always waits for a timeout is held live by the timeout.  Such servers need to support an explicit kill protocol.</p>
<p> When a timeout is used as a part of a non-deterministic choice, e.g. <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a>&nbsp;span&nbsp;<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a>&nbsp;somethingElse</code>, and some other alternative is committed to before the timeout expires, the memory held by the timeout can be released by the timer mechanism.  However, when a timeout is not part of a non-deterministic choice, e.g.</p>
<pre><code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a> span <a href="#def:val%20Hopac.Infixes.&gt;&gt;=.">&gt;&gt;=.</a> gotTimeout <a href="#def:val%20Hopac.Infixes.*&lt;=">*&lt;=</a> () |&gt; <a href="#def:val%20Hopac.Hopac.start">start</a>
</code></pre>
<p> no such clean up can be performed.  If there is a possibility that such timeouts are kept alive beyond their usefulness, it may be possible to arrange for the timeouts to be released by making them part of a non-deterministic choice:</p>
<pre><code class="fsharp hljs">    <a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a> span <a href="#def:val%20Hopac.Infixes.^=&gt;">^=&gt;</a> <a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.tryFill">tryFill</a> gotTimeoutOrDoneOtherwise
<a href="#def:val%20Hopac.Infixes.&lt;|&gt;">&lt;|&gt;</a> gotTimeoutOrDoneOtherwise
 |&gt; <a href="#def:val%20Hopac.Hopac.start">start</a>
</code></pre>
<p> The idea is that the <code class="fsharp hljs">gotTimeoutOrDoneOtherwise</code> is filled, using <code class="fsharp hljs"><a href="#def:module%20Hopac.IVar">IVar</a>.<a href="#def:val%20Hopac.IVar.tryFill">tryFill</a></code> as soon as the timeout is no longer useful.  This allows the timer mechanism to release the memory held by the timeout.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.timeOutMillis" href="#dec:val%20Hopac.Hopac.timeOutMillis">timeOutMillis</a>: int -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;unit&gt;
</code></pre>
<p> <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.timeOutMillis">timeOutMillis</a>&nbsp;n</code> is equivalent to <code class="fsharp hljs"><a href="#def:val%20Hopac.Hopac.timeOut">timeOut</a>&nbsp;&lt;&lt;&nbsp;TimeSpan.FromMilliseconds&nbsp;&lt;|&nbsp;float&nbsp;n</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.memo" href="#dec:val%20Hopac.Hopac.memo">memo</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Promise">Promise</a>&lt;'x&gt;
</code></pre>
<p> Creates a promise whose value is computed lazily with the given job when an attempt is made to read the promise.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.asAlt" href="#dec:val%20Hopac.Hopac.asAlt">asAlt</a>: <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Alt">Alt</a>&lt;'x&gt;
</code></pre>
<p> Use object as alternative.  This function is a NOP and is provided as a kind of syntactic alternative to using a type ascription or an <code class="fsharp hljs">upcast</code>.</p>
</div>
<div class="description"><pre><code class="fsharp hljs">val <a id="def:val Hopac.Hopac.asJob" href="#dec:val%20Hopac.Hopac.asJob">asJob</a>: <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Job">Job</a>&lt;'x&gt;
</code></pre>
<p> Use object as job.  This function is a NOP and is provided as a kind of syntactic alternative to using a type ascription or an <code class="fsharp hljs">upcast</code>.</p>
</div>
</div>
</div>
</td></tr></table></body>
</html>
